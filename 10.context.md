### CONTEXT creation

```go
package main

import (
	"context"
	"fmt"
)

// context - instance of a struct / obj{}.
// used in API making (REST, gRPC)

//üí° Two ways of creating a context:-
// 1. context.TODO()
// 2. context.Background()

//üåüIn a very BROADER way:- Contexts are variables that store values in k/v pairs, upon creation, they can also carry cancellation signals, deadlines, request-coped values, etc.

//‚úÖ context.TODO():- 
// Used when we are unsure/unclear about which ctxt to use, or plan to use a proper ctxt later. It just acts as a PLACEHOLDER. Conventionally, it does/should not carry any deadlines, cancellations, etc. Returns a todoCtx (empty Ctx).

//‚òëÔ∏è context.Background() :- 
// returns a backgroundCtx (empty Ctx).


func main() {
	todoCtxt := context.TODO()
	bgCtxt := context.Background()

	ctxt:= context.WithValue(todoCtxt, "name","Skyy")
	ctxtBg:= context.WithValue(bgCtxt, "city","Kolkata")

	fmt.Println(ctxt)
	fmt.Println(ctxt.Value("name"))

	fmt.Println(ctxtBg)
	fmt.Println(ctxtBg.Value("city"))
}

// O/P:-
// $ go run .
// context.TODO.WithValue(name, Skyy)
// Skyy
// context.Background.WithValue(city, Kolkata)
// Kolkata

```
### context.TODO()
```go
package main

import (
	"context"
	"fmt"
	"time"
)

// context.TODO() example
func checkEvenOrOdd(ctx context.Context, num int )string{
	select {
	case <-ctx.Done():
		return "Operation cancelled!"
	default:
		if num%2==0{
			return  fmt.Sprintf("%d is even ‚úÖ",num)
		} else{
			return  fmt.Sprintf("%d is odd ‚òëÔ∏è",num)
		}	
	}
	
}

func main() {
	ctx:= context.TODO()
	result:= checkEvenOrOdd(ctx,5)
	fmt.Println("Result with context.TODO() :",result)

	ctx = context.Background()

	ctx,cancel:= context.WithTimeout(ctx, 1*time.Second)
	defer cancel()

	// once again
	result = checkEvenOrOdd(ctx, 10)
	fmt.Println("Result with timeout context:",result)
	 defer cancel()

	

	// now, sleep..
	time.Sleep(2*time.Second)
	result = checkEvenOrOdd(ctx, 15)
	fmt.Println("Result with after sleep/timeout:",result)

	//O/P:
	// $ go run .
	// Result with context.TODO() : 5 is odd ‚òëÔ∏è
	// Result with timeout context: 10 is even ‚úÖ
	// Result with after sleep/timeout: Operation cancelled!

}

```

### CTX WITH TIMEOUT
```golang
package main

import (
	"context"
	"fmt"
	"time"
)

// Storing some value in the ctx and also use that ctx with timeout

func doWork(ctx context.Context){
	for{
		select {
		case <-ctx.Done():
			fmt.Println("üî¥ Work cancelled:",ctx.Err())
			return
		default:
			fmt.Println("Working.. ‚úÖ")
		}
		time.Sleep(500 * time.Millisecond)
	}
}

func main() {
	ctx:= context.Background();
	ctx, cancelFx:=context.WithTimeout(ctx, 2 * time.Second)
    /* (ctx, 2 * time.Second) - timer of the ctxt starts here. 
    We have this specific time duration to use this ctxt. After this, the ctxt will send a cancellation signal.
    */
    
	defer cancelFx()

	ctx= context.WithValue(ctx, "reqID","abcd1234")

	go doWork(ctx)

	time.Sleep(3 * time.Second)

	requestId:= ctx.Value("reqID")

	if requestId!=nil{
		fmt.Println("Request ID:",requestId)
	}else{
		fmt.Println("No request ID found!")
	}

// $ go run .
// Working.. ‚úÖ
// Working.. ‚úÖ
// Working.. ‚úÖ
// Working.. ‚úÖ
// üî¥ Work cancelled: context deadline exceeded
// Request ID: abcd1234

}
```
This one demonstrates **two powerful features** of Go‚Äôs `context` package working together:

1. **Timeout-based cancellation** (`context.WithTimeout`)
2. **Passing request-scoped values** (`context.WithValue`)

Let‚Äôs go through it **line by line**, understand what‚Äôs happening under the hood, and why the output looks exactly the way it does.

---

## üß† Big Picture

We‚Äôre simulating a background goroutine (`doWork`) that continuously does some work every half second, but should **stop automatically after 2 seconds**.

Meanwhile, we also store a **metadata value** (`reqID`) inside the same context ‚Äî something often done in real-world servers for tracking requests.

---

## üìú Full Code for Reference

```go
package main

import (
	"context"
	"fmt"
	"time"
)

func doWork(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			fmt.Println("üî¥ Work cancelled:", ctx.Err())
			return
		default:
			fmt.Println("Working.. ‚úÖ")
		}
		time.Sleep(500 * time.Millisecond)
	}
}

func main() {
	ctx := context.Background()
	ctx, cancelFx := context.WithTimeout(ctx, 2*time.Second)
	defer cancelFx()

	ctx = context.WithValue(ctx, "reqID", "abcd1234")

	go doWork(ctx)

	time.Sleep(3 * time.Second)

	requestId := ctx.Value("reqID")

	if requestId != nil {
		fmt.Println("Request ID:", requestId)
	} else {
		fmt.Println("No request ID found!")
	}
}
```

---

## ü™ú Step-by-Step Breakdown

### üü¢ Step 1: Create a Root Context

```go
ctx := context.Background()
```

This creates the **base/root context** ‚Äî it never cancels or times out by itself.
We‚Äôll use this as a **parent** to derive new contexts.

---

### üïí Step 2: Add a Timeout

```go
ctx, cancelFx := context.WithTimeout(ctx, 2*time.Second)
defer cancelFx()
```

Now we‚Äôve created a **child context** that:

* Automatically **cancels itself after 2 seconds**.
* Internally starts a **timer**.
* When the timer expires, Go:

  * Closes the internal `ctx.Done()` channel.
  * Sets the error to `context.DeadlineExceeded`.

So we can visualize:

```
Parent: Background()
   ‚Üì
Child: WithTimeout(2s)
```

This child will automatically expire after 2 seconds.

---

### üü£ Step 3: Attach a Value

```go
ctx = context.WithValue(ctx, "reqID", "abcd1234")
```

We now derive **another child context** from the timeout context that **stores a key-value pair**.

So now the chain looks like:

```
Background ‚Üí WithTimeout(2s) ‚Üí WithValue("reqID": "abcd1234")
```

Each context *inherits cancellation* from its parent, so if the timeout triggers, this one also gets canceled.

The value is stored in a lightweight map-like structure inside the context ‚Äî but it‚Äôs only meant for **request-scoped metadata**, not general data passing.

---

### üßµ Step 4: Start a Goroutine

```go
go doWork(ctx)
```

Now we start a new goroutine that continuously does ‚Äúwork‚Äù until canceled.

Let‚Äôs look at the function:

```go
func doWork(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			fmt.Println("üî¥ Work cancelled:", ctx.Err())
			return
		default:
			fmt.Println("Working.. ‚úÖ")
		}
		time.Sleep(500 * time.Millisecond)
	}
}
```

Here‚Äôs what happens:

* The `select` checks two things:

  1. `ctx.Done()` ‚Äî a **channel** that closes when context is canceled.
  2. `default` ‚Äî executes when no other case is ready.

* Every 500ms, it prints ‚ÄúWorking.. ‚úÖ‚Äù.

After 2 seconds, the timeout fires.
At that moment, the `ctx.Done()` channel closes, and `ctx.Err()` becomes `context.DeadlineExceeded`.

So the next time the `select` runs, it matches the **`<-ctx.Done()`** case instead of `default`, prints:

```
üî¥ Work cancelled: context deadline exceeded
```

and returns, ending the goroutine gracefully.

---

### ‚è± Step 5: Sleep in Main (3s)

```go
time.Sleep(3 * time.Second)
```

We wait 3 seconds to ensure:

* The goroutine runs for at least 2 seconds (doing work).
* Then it cancels itself after timeout.
* Then the main goroutine continues.

---

### üü§ Step 6: Retrieve Value from Context

```go
requestId := ctx.Value("reqID")
```

We fetch the stored value using the same key `"reqID"`.
Even though the context is *timed out*, its **values remain accessible** ‚Äî cancellation doesn‚Äôt delete values.

Hence, `requestId` returns `"abcd1234"`.

üßæ Printed output:

```
Request ID: abcd1234
```

---

## üì§ Final Output Explained

```
Working.. ‚úÖ       // from doWork goroutine
Working.. ‚úÖ
Working.. ‚úÖ
Working.. ‚úÖ
üî¥ Work cancelled: context deadline exceeded   // after 2s
Request ID: abcd1234                           // after main wakes up
```

---

## ‚öôÔ∏è Under the Hood

Internally, Go‚Äôs runtime handles this using **timer goroutines and channel notifications**:

1. `context.WithTimeout` spawns an internal timer.
2. When the timer expires:

   * It closes the `done` channel.
   * All goroutines blocked on `<-ctx.Done()` are unblocked immediately.
3. `context.WithValue` just wraps another context struct and overrides the `Value()` method to look for your key.

---

## ‚ö†Ô∏è Best Practices

| Practice                                          | Why                                                                      |
| ------------------------------------------------- | ------------------------------------------------------------------------ |
| Always call `defer cancelFx()`                    | Prevents goroutine & timer leaks                                         |
| Use `context.WithValue` only for metadata         | Avoid passing functional data through context                            |
| Always check `<-ctx.Done()` in long-running loops | Ensures graceful cancellation                                            |
| Don‚Äôt ignore `ctx.Err()`                          | Tells you *why* cancellation happened (`Canceled` or `DeadlineExceeded`) |

---

## ‚úÖ Summary Table

| Concept                      | Description                                              |
| ---------------------------- | -------------------------------------------------------- |
| `context.Background()`       | Root context ‚Äî never cancels                             |
| `context.WithTimeout()`      | Cancels automatically after duration                     |
| `context.WithValue()`        | Stores key-value metadata                                |
| `ctx.Done()`                 | Channel closed when cancelled                            |
| `ctx.Err()`                  | Returns `context.Canceled` or `context.DeadlineExceeded` |
| Cancellation propagation     | If parent cancels, all children cancel too               |
| Values persist after timeout | You can still read `ctx.Value()` after timeout           |

---

### CTXT WITH CANCEL()
```go
package main

import (
	"context"
	"fmt"
	"log"
	"time"
)

// ctxt with cancel() example
// manually run the cancel func()

func doWork(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			fmt.Println("üî¥ Work cancelled:", ctx.Err())
			return
		default:
			fmt.Println("Working.. ‚úÖ")
		}
		time.Sleep(500 * time.Millisecond)
	}
}

func main() {
	ctx:= context.Background();
	ctx, cancelFx:=context.WithCancel(ctx)
	// defer cancelFx() ‚ùå

	go func(){
		time.Sleep(2 * time.Second) // simulating heavy-task (time consuming op.)
		cancelFx() // manually/only after tast completion
		}()

	ctx = context.WithValue(ctx, "reqID", "abcd1234")

	go doWork(ctx)

	time.Sleep(3 * time.Second)

	requestId:= ctx.Value("reqID")

	if requestId!=nil{
		fmt.Println("Request ID:",requestId)
	}else{
		fmt.Println("No request ID found!")
	}

	logWithCtxt(ctx, "This a test logger message ‚òëÔ∏è")
}

// create ctxt with value: ctx.withValue()
// extracrting the value: ctx.Value()

func logWithCtxt(ctx context.Context, message string){
reqIdVal:=ctx.Value("reqID")
log.Printf("ReqID: %v - %v",reqIdVal,message)
}

//OP-
//$ go run .
// Working.. ‚úÖ
// Working.. ‚úÖ
// Working.. ‚úÖ
// Working.. ‚úÖ
// üî¥ Work cancelled: context canceled
// Request ID: abcd1234
// 2025/10/08 05:25:28 ReqID: abcd1234 - This a test logger message ‚òëÔ∏è
```
This is a *beautifully written* Go example that demonstrates **context cancellation**, **context values**, and **context propagation**. Let‚Äôs break it down step-by-step to fully understand what‚Äôs happening and why we need each part üëá

---

## üß© What this code demonstrates

This code shows three **core use-cases of `context.Context`**:

1. **Cancellation** ‚Äî stop a goroutine gracefully.
2. **Value propagation** ‚Äî pass request-scoped values (like a request ID).
3. **Context awareness** ‚Äî let goroutines react to cancellation and carry metadata.

---

## üß† Let‚Äôs go line by line

### 1Ô∏è‚É£ Creating the base context

```go
ctx := context.Background()
```

* `context.Background()` is the **root** context.
* It‚Äôs never canceled, has no values, and is the starting point for creating child contexts.

---

### 2Ô∏è‚É£ Creating a cancellable context

```go
ctx, cancelFx := context.WithCancel(ctx)
```

* We create a **child context** (`ctx`) that inherits from the parent (`context.Background()`).
* It returns a **cancel function** `cancelFx`.
* When `cancelFx()` is called, it **sends a cancellation signal** down the context tree.

This is used to **gracefully stop** goroutines or operations.

---

### 3Ô∏è‚É£ Simulating a long task

```go
go func() {
    time.Sleep(2 * time.Second)
    cancelFx() // manually cancels after 2s
}()
```

* This goroutine waits for 2 seconds (like a simulated long-running operation).
* Then, it calls `cancelFx()` ‚Äî signaling all goroutines that use `ctx` to **stop their work**.

---

### 4Ô∏è‚É£ Adding a value to context

```go
ctx = context.WithValue(ctx, "reqID", "abcd1234")
```

* Creates a **new context** derived from `ctx`, carrying a key-value pair.
* Now any goroutine that receives this context can extract the `"reqID"` key.
* This is typically used for **logging**, **tracing**, or **request-scoped data**.

---

### 5Ô∏è‚É£ Running a worker goroutine

```go
go doWork(ctx)
```

Now we launch a goroutine that continuously ‚Äúdoes work‚Äù ‚Äî but listens for cancellation.

---

### 6Ô∏è‚É£ The worker function

```go
func doWork(ctx context.Context) {
	for {
		select {
		case <-ctx.Done(): // üî• cancellation signal received
			fmt.Println("üî¥ Work cancelled:", ctx.Err())
			return
		default:
			fmt.Println("Working.. ‚úÖ")
		}
		time.Sleep(500 * time.Millisecond)
	}
}
```

Let‚Äôs unpack the key part:

* The `select` statement is listening for `ctx.Done()` ‚Äî
  this is a **channel** that closes when the context is canceled.
* `ctx.Err()` returns the **reason** for cancellation (usually `"context canceled"`).
* When not canceled, it prints `Working.. ‚úÖ` every 500ms.

So, for 2 seconds, it keeps printing ‚ÄúWorking.. ‚úÖ‚Äù
After 2 seconds ‚Üí cancellation signal ‚Üí it prints:

```
üî¥ Work cancelled: context canceled
```

---

### 7Ô∏è‚É£ Using the context‚Äôs value later

After 3 seconds:

```go
requestId := ctx.Value("reqID")
if requestId != nil {
	fmt.Println("Request ID:", requestId)
}
```

* Retrieves the value we stored earlier with `"reqID"`.
* Even though the context was canceled, the **value is still retrievable**.
* Output:

  ```
  Request ID: abcd1234
  ```

---

### 8Ô∏è‚É£ Logging with context values

```go
logWithCtxt(ctx, "This a test logger message ‚òëÔ∏è")
```

```go
func logWithCtxt(ctx context.Context, message string) {
	reqIdVal := ctx.Value("reqID")
	log.Printf("ReqID: %v - %v", reqIdVal, message)
}
```

This is a realistic example of how context is used in production ‚Äî
Every log entry includes a **request ID** (or user ID, trace ID, etc.), so logs can be **traced per request**.

Output:

```
2025/10/08 05:25:28 ReqID: abcd1234 - This a test logger message ‚òëÔ∏è
```

---

## ‚öôÔ∏è Output Summary

```
Working.. ‚úÖ
Working.. ‚úÖ
Working.. ‚úÖ
Working.. ‚úÖ
üî¥ Work cancelled: context canceled
Request ID: abcd1234
2025/10/08 05:25:28 ReqID: abcd1234 - This a test logger message ‚òëÔ∏è
```

Timeline:

| Time | Event                                |
| ---- | ------------------------------------ |
| 0s   | Goroutine starts working             |
| 2s   | cancelFx() called ‚Äî context canceled |
| 2s   | Worker prints ‚ÄúWork cancelled‚Äù       |
| 3s   | Request ID and log printed           |

---

## üß© Why not just use a bool flag instead of context?

We **could**, but that‚Äôs unsafe and doesn‚Äôt scale.
`context.Context` gives us:

* ‚úÖ **Thread-safe** cancellation across goroutines.
* ‚úÖ **Deadline & timeout support** (`context.WithTimeout`, `context.WithDeadline`).
* ‚úÖ **Value propagation** for request-scoped data.
* ‚úÖ **Standard interface** ‚Äî every Go library expects `ctx context.Context`.

So contexts are a **standardized, structured, and cancellable way** to manage goroutine lifetimes and carry metadata.
---
