### Creating with NEWTIMER()
```go
package main

import (
	"fmt"
	"time"
)

// timer in action - sending the current time after a certain period
func main() {
	fmt.Println("Starting app..")
	timer := time.NewTimer(2 * time.Second) // Non-blocking in nature (unlike time.Sleep())
	fmt.Println("Waiting for timer.C")
	stopped:=timer.Stop()
	if stopped{
		fmt.Println("Timer stopped..")
	}
	fmt.Println("Timer reset()..")
	timer.Reset(time.Second)
	<- timer.C // blocking in nature
	fmt.Println("Timer expired!")

	//OP:
    // $ go run .
    // Starting app..
    // Waiting for timer.C
    // Timer stopped..
    // Timer reset()..
    // Timer expired!

}
```
This code beautifully demonstrates **how timers work in Go**, how to **stop** and **reset** them, and how the `<-timer.C` channel operates under the hood.
---

## 🧠 Big Picture: What’s a Timer in Go?

A **`time.Timer`** is used to **trigger an event after a specific duration**.

When we create one using:

```go
timer := time.NewTimer(2 * time.Second)
```

it returns a struct like:

```go
type Timer struct {
    C <-chan Time  // Channel that sends a time.Time value when the timer fires
    // (internal fields managed by runtime)
}
```

So, **`timer.C`** is a **channel** that will receive **the current time** when the timer expires.
That’s how timers communicate in Go’s concurrency model — through channels.

---

## ⚙️ Step-by-step Explanation of the Code

```go
fmt.Println("Starting app..")
```

→ Just a log message to indicate program start.

---

### 🕐 1️⃣ Creating a Timer

```go
timer := time.NewTimer(2 * time.Second)
```

✅ This **creates** a timer that will fire after **2 seconds**.

🔹 Internally, the Go runtime:

* Starts a goroutine that waits for 2 seconds.
* When the duration elapses, it sends the **current timestamp** into the channel `timer.C`.

So you can imagine:

```go
after 2s → timer.C <- time.Now()
```

**Note:**
Unlike `time.Sleep()`, this doesn’t block your main goroutine.
It’s **non-blocking** — it simply *starts* a background countdown.

---

### 🕓 2️⃣ Waiting for the Timer

```go
fmt.Println("Waiting for timer.C")
```

This line runs **immediately** because the timer hasn’t fired yet.

---

### ⏹️ 3️⃣ Stopping the Timer

```go
stopped := timer.Stop()
if stopped {
    fmt.Println("Timer stopped..")
}
```

Here’s what happens:

* `timer.Stop()` tries to **prevent** the timer from sending a value into `timer.C`.
* It returns `true` if the timer was **active** and **successfully stopped before firing**.
* It returns `false` if the timer had **already fired** or **expired**.

In this case:

* Since we just created the timer, and 2 seconds haven’t passed yet →
  ✅ `stopped` is `true`.

So output:

```
Timer stopped..
```

💡 Internally, Go removes the timer’s event from its internal “heap” of timers.

---

### 🔁 4️⃣ Resetting the Timer

```go
fmt.Println("Timer reset()..")
timer.Reset(time.Second)
```

Now we’re saying:

> “Hey Go, start the timer again — but this time, fire after 1 second.”

When you call `.Reset(d)`:

* It reuses the **same timer object**.
* It schedules it again for a new duration (`1s`).
* Returns `true` if it was active, `false` otherwise.

---

### ⏳ 5️⃣ Waiting for Expiry (Blocking)

```go
<-timer.C
fmt.Println("Timer expired!")
```

This is the **blocking** part.

We’re saying:

> “Wait (block) until we receive something from `timer.C`.”

So the main goroutine **pauses** here until the timer sends the value.

After 1 second, the timer fires:

```
timer.C <- time.Now()
```

and `<-timer.C` unblocks.

Then we print:

```
Timer expired!
```

---

## 🧩 Full Flow Recap

```
Starting app..
Waiting for timer.C
Timer stopped..
Timer reset()..
Timer expired!
```

### Timeline Visualization:

| Time (s) | Event                                   |
| -------- | --------------------------------------- |
| 0        | Timer(2s) created                       |
| 0        | `Stop()` called → cancels timer         |
| 0        | `Reset(1s)` called → new 1s countdown   |
| 1        | timer.C fires → main goroutine unblocks |
| 1        | “Timer expired!” printed                |

---

## ⚡ Difference Between `Sleep()` and `Timer`

| Feature       | `time.Sleep()`           | `time.NewTimer()`        |
| ------------- | ------------------------ | ------------------------ |
| Blocking      | Blocks current goroutine | Non-blocking             |
| Cancelable    | ❌ No                     | ✅ Yes, via `Stop()`      |
| Resettable    | ❌ No                     | ✅ Yes, via `Reset()`     |
| Communication | None                     | Uses channel `C`         |
| Use Case      | Simple delay             | Coordinated async events |

---

## 🧬 What’s Under the Hood?

Go runtime maintains a **min-heap** of timers, each with:

* `when`: the expiration time (in nanoseconds)
* `period`: for tickers
* `f`: the function to run (or send to channel)

The runtime scheduler:

* Continuously checks for the earliest timer event.
* When the time comes, it **sends a timestamp** to `timer.C` (non-blocking send).
* Goroutines waiting on `<-timer.C` get unblocked.

---

## 💡 Practical Use Cases

✅ Cancelling timeouts
✅ Retrying failed network calls
✅ Triggering delayed actions
✅ Combining with `select` for timeout handling

Example:

```go
select {
case <-timer.C:
    fmt.Println("Timeout!")
case <-done:
    fmt.Println("Operation finished early!")
}
```

---
