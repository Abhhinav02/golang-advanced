### Creating with NEWTIMER()
```go
package main

import (
	"fmt"
	"time"
)

// timer in action - sending the current time after a certain period
func main() {
	fmt.Println("Starting app..")
	timer := time.NewTimer(2 * time.Second) // Non-blocking in nature (unlike time.Sleep())
	fmt.Println("Waiting for timer.C")
	stopped:=timer.Stop()
	if stopped{
		fmt.Println("Timer stopped..")
	}
	fmt.Println("Timer reset()..")
	timer.Reset(time.Second)
	<- timer.C // blocking in nature
	fmt.Println("Timer expired!")

	//OP:
    // $ go run .
    // Starting app..
    // Waiting for timer.C
    // Timer stopped..
    // Timer reset()..
    // Timer expired!

}
```
This code beautifully demonstrates **how timers work in Go**, how to **stop** and **reset** them, and how the `<-timer.C` channel operates under the hood.
---

## ğŸ§  Big Picture: Whatâ€™s a Timer in Go?

A **`time.Timer`** is used to **trigger an event after a specific duration**.

When we create one using:

```go
timer := time.NewTimer(2 * time.Second)
```

it returns a struct like:

```go
type Timer struct {
    C <-chan Time  // Channel that sends a time.Time value when the timer fires
    // (internal fields managed by runtime)
}
```

So, **`timer.C`** is a **channel** that will receive **the current time** when the timer expires.
Thatâ€™s how timers communicate in Goâ€™s concurrency model â€” through channels.

---

## âš™ï¸ Step-by-step Explanation of the Code

```go
fmt.Println("Starting app..")
```

â†’ Just a log message to indicate program start.

---

### ğŸ• 1ï¸âƒ£ Creating a Timer

```go
timer := time.NewTimer(2 * time.Second)
```

âœ… This **creates** a timer that will fire after **2 seconds**.

ğŸ”¹ Internally, the Go runtime:

* Starts a goroutine that waits for 2 seconds.
* When the duration elapses, it sends the **current timestamp** into the channel `timer.C`.

So you can imagine:

```go
after 2s â†’ timer.C <- time.Now()
```

**Note:**
Unlike `time.Sleep()`, this doesnâ€™t block your main goroutine.
Itâ€™s **non-blocking** â€” it simply *starts* a background countdown.

---

### ğŸ•“ 2ï¸âƒ£ Waiting for the Timer

```go
fmt.Println("Waiting for timer.C")
```

This line runs **immediately** because the timer hasnâ€™t fired yet.

---

### â¹ï¸ 3ï¸âƒ£ Stopping the Timer

```go
stopped := timer.Stop()
if stopped {
    fmt.Println("Timer stopped..")
}
```

Hereâ€™s what happens:

* `timer.Stop()` tries to **prevent** the timer from sending a value into `timer.C`.
* It returns `true` if the timer was **active** and **successfully stopped before firing**.
* It returns `false` if the timer had **already fired** or **expired**.

In this case:

* Since we just created the timer, and 2 seconds havenâ€™t passed yet â†’
  âœ… `stopped` is `true`.

So output:

```
Timer stopped..
```

ğŸ’¡ Internally, Go removes the timerâ€™s event from its internal â€œheapâ€ of timers.

---

### ğŸ” 4ï¸âƒ£ Resetting the Timer

```go
fmt.Println("Timer reset()..")
timer.Reset(time.Second)
```

Now weâ€™re saying:

> â€œHey Go, start the timer again â€” but this time, fire after 1 second.â€

When you call `.Reset(d)`:

* It reuses the **same timer object**.
* It schedules it again for a new duration (`1s`).
* Returns `true` if it was active, `false` otherwise.

---

### â³ 5ï¸âƒ£ Waiting for Expiry (Blocking)

```go
<-timer.C
fmt.Println("Timer expired!")
```

This is the **blocking** part.

Weâ€™re saying:

> â€œWait (block) until we receive something from `timer.C`.â€

So the main goroutine **pauses** here until the timer sends the value.

After 1 second, the timer fires:

```
timer.C <- time.Now()
```

and `<-timer.C` unblocks.

Then we print:

```
Timer expired!
```

---

## ğŸ§© Full Flow Recap

```
Starting app..
Waiting for timer.C
Timer stopped..
Timer reset()..
Timer expired!
```

### Timeline Visualization:

| Time (s) | Event                                   |
| -------- | --------------------------------------- |
| 0        | Timer(2s) created                       |
| 0        | `Stop()` called â†’ cancels timer         |
| 0        | `Reset(1s)` called â†’ new 1s countdown   |
| 1        | timer.C fires â†’ main goroutine unblocks |
| 1        | â€œTimer expired!â€ printed                |

---

## âš¡ Difference Between `Sleep()` and `Timer`

| Feature       | `time.Sleep()`           | `time.NewTimer()`        |
| ------------- | ------------------------ | ------------------------ |
| Blocking      | Blocks current goroutine | Non-blocking             |
| Cancelable    | âŒ No                     | âœ… Yes, via `Stop()`      |
| Resettable    | âŒ No                     | âœ… Yes, via `Reset()`     |
| Communication | None                     | Uses channel `C`         |
| Use Case      | Simple delay             | Coordinated async events |

---

## ğŸ§¬ Whatâ€™s Under the Hood?

Go runtime maintains a **min-heap** of timers, each with:

* `when`: the expiration time (in nanoseconds)
* `period`: for tickers
* `f`: the function to run (or send to channel)

The runtime scheduler:

* Continuously checks for the earliest timer event.
* When the time comes, it **sends a timestamp** to `timer.C` (non-blocking send).
* Goroutines waiting on `<-timer.C` get unblocked.

---

## ğŸ’¡ Practical Use Cases

âœ… Cancelling timeouts
âœ… Retrying failed network calls
âœ… Triggering delayed actions
âœ… Combining with `select` for timeout handling

Example:

```go
select {
case <-timer.C:
    fmt.Println("Timeout!")
case <-done:
    fmt.Println("Operation finished early!")
}
```

---
