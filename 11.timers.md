### Creating with NEWTIMER()
```go
package main

import (
	"fmt"
	"time"
)

// timer in action - sending the current time after a certain period
func main() {
	fmt.Println("Starting app..")
	timer := time.NewTimer(2 * time.Second) // Non-blocking in nature (unlike time.Sleep())
	fmt.Println("Waiting for timer.C")
	stopped:=timer.Stop()
	if stopped{
		fmt.Println("Timer stopped..")
	}
	fmt.Println("Timer reset()..")
	timer.Reset(time.Second)
	<- timer.C // blocking in nature
	fmt.Println("Timer expired!")

	//OP:
    // $ go run .
    // Starting app..
    // Waiting for timer.C
    // Timer stopped..
    // Timer reset()..
    // Timer expired!

}
```
This code beautifully demonstrates **how timers work in Go**, how to **stop** and **reset** them, and how the `<-timer.C` channel operates under the hood.
---

## 🧠 Big Picture: What’s a Timer in Go?

A **`time.Timer`** is used to **trigger an event after a specific duration**.

When we create one using:

```go
timer := time.NewTimer(2 * time.Second)
```

it returns a struct like:

```go
type Timer struct {
    C <-chan Time  // Channel that sends a time.Time value when the timer fires
    // (internal fields managed by runtime)
}
```

So, **`timer.C`** is a **channel** that will receive **the current time** when the timer expires.
That’s how timers communicate in Go’s concurrency model — through channels.

---

## ⚙️ Step-by-step Explanation of the Code

```go
fmt.Println("Starting app..")
```

→ Just a log message to indicate program start.

---

### 🕐 1️⃣ Creating a Timer

```go
timer := time.NewTimer(2 * time.Second)
```

✅ This **creates** a timer that will fire after **2 seconds**.

🔹 Internally, the Go runtime:

* Starts a goroutine that waits for 2 seconds.
* When the duration elapses, it sends the **current timestamp** into the channel `timer.C`.

So we can imagine:

```go
after 2s → timer.C <- time.Now()
```

**Note:**
Unlike `time.Sleep()`, this doesn’t block our main goroutine.
It’s **non-blocking** — it simply *starts* a background countdown.

---

### 🕓 2️⃣ Waiting for the Timer

```go
fmt.Println("Waiting for timer.C")
```

This line runs **immediately** because the timer hasn’t fired yet.

---

### ⏹️ 3️⃣ Stopping the Timer

```go
stopped := timer.Stop()
if stopped {
    fmt.Println("Timer stopped..")
}
```

Here’s what happens:

* `timer.Stop()` tries to **prevent** the timer from sending a value into `timer.C`.
* It returns `true` if the timer was **active** and **successfully stopped before firing**.
* It returns `false` if the timer had **already fired** or **expired**.

In this case:

* Since we just created the timer, and 2 seconds haven’t passed yet →
  ✅ `stopped` is `true`.

So output:

```
Timer stopped..
```

💡 Internally, Go removes the timer’s event from its internal “heap” of timers.

---

### 🔁 4️⃣ Resetting the Timer

```go
fmt.Println("Timer reset()..")
timer.Reset(time.Second)
```

Now we’re saying:

> “Hey Go, start the timer again — but this time, fire after 1 second.”

When we call `.Reset(d)`:

* It reuses the **same timer object**.
* It schedules it again for a new duration (`1s`).
* Returns `true` if it was active, `false` otherwise.

---

### ⏳ 5️⃣ Waiting for Expiry (Blocking)

```go
<-timer.C
fmt.Println("Timer expired!")
```

This is the **blocking** part.

We’re saying:

> “Wait (block) until we receive something from `timer.C`.”

So the main goroutine **pauses** here until the timer sends the value.

After 1 second, the timer fires:

```
timer.C <- time.Now()
```

and `<-timer.C` unblocks.

Then we print:

```
Timer expired!
```

---

## 🧩 Full Flow Recap

```
Starting app..
Waiting for timer.C
Timer stopped..
Timer reset()..
Timer expired!
```

### Timeline Visualization:

| Time (s) | Event                                   |
| -------- | --------------------------------------- |
| 0        | Timer(2s) created                       |
| 0        | `Stop()` called → cancels timer         |
| 0        | `Reset(1s)` called → new 1s countdown   |
| 1        | timer.C fires → main goroutine unblocks |
| 1        | “Timer expired!” printed                |

---

## ⚡ Difference Between `Sleep()` and `Timer`

| Feature       | `time.Sleep()`           | `time.NewTimer()`        |
| ------------- | ------------------------ | ------------------------ |
| Blocking      | Blocks current goroutine | Non-blocking             |
| Cancelable    | ❌ No                     | ✅ Yes, via `Stop()`      |
| Resettable    | ❌ No                     | ✅ Yes, via `Reset()`     |
| Communication | None                     | Uses channel `C`         |
| Use Case      | Simple delay             | Coordinated async events |

---

## 🧬 What’s Under the Hood?

Go runtime maintains a **min-heap** of timers, each with:

* `when`: the expiration time (in nanoseconds)
* `period`: for tickers
* `f`: the function to run (or send to channel)

The runtime scheduler:

* Continuously checks for the earliest timer event.
* When the time comes, it **sends a timestamp** to `timer.C` (non-blocking send).
* Goroutines waiting on `<-timer.C` get unblocked.

---

## 💡 Practical Use Cases

✅ Cancelling timeouts
✅ Retrying failed network calls
✅ Triggering delayed actions
✅ Combining with `select` for timeout handling

Example:

```go
select {
case <-timer.C:
    fmt.Println("Timeout!")
case <-done:
    fmt.Println("Operation finished early!")
}
```
---

### time.After()
```go
package main

import (
	"fmt"
	"time"
)

// time.After() - After waits for the duration to elapse and then sends the current time on the returned channel.
func main() {
	timeOut:=time.After(3*time.Second)
	done:= make(chan bool)

	go func ()  {
		longRunningOp()
		done <-true
	}()

	select{
	case <-timeOut:
		fmt.Println("Operation timed out!.. 🔴")
	case <-done:
		fmt.Println("✅ Operation completed/done!")	
	}

	// OP:
	// $ go run .
	// 0
	// 1
	// 2
	// Operation timed out!.. 🔴
	

}

// simulating a resource-heavy/time-consuming func()
func longRunningOp(){
	for i:=range 20{
       fmt.Println(i)
	   time.Sleep(time.Second) // sleep after every rep.
	}
}
```
This is a **classic Go timeout pattern** 👑

It shows how to use **`time.After()` with `select`** to handle **timeouts** while running potentially long or blocking operations concurrently.
---

## 🧠 Big Picture

We’re running a **long-running operation** (`longRunningOp`) in a goroutine,
and at the same time, we start a **3-second timeout** using `time.After()`.

Then, we use a **`select` statement** to wait for **whichever happens first**:

* The operation finishes ✅
* The timeout fires 🔴

---

## ⚙️ Step-by-Step Breakdown

### 1️⃣ Start of `main`

```go
timeOut := time.After(3 * time.Second)
done := make(chan bool)
```

Let’s unpack each:

#### `time.After(3 * time.Second)`

* This function **creates and returns a channel** (`<-chan time.Time`).
* After 3 seconds, the current time is sent into that channel.

Essentially, it’s a shorthand for:

```go
timer := time.NewTimer(3 * time.Second)
return timer.C
```

So, `time.After()` is just syntactic sugar for making a one-shot timer.

➡️ It **does not block** immediately — it runs a background countdown and returns instantly.

---

#### `done := make(chan bool)`

We create a channel to **signal completion** of the long operation.

The main goroutine will wait for either:

* A signal from `done` → success ✅
* A signal from `timeOut` → timeout 🔴

---

### 2️⃣ Run the Long Operation in a Separate Goroutine

```go
go func() {
    longRunningOp()
    done <- true
}()
```

* We run `longRunningOp()` asynchronously in a new goroutine.
* Once it finishes, we send `true` into `done` to signal completion.

This prevents the main goroutine from blocking while `longRunningOp()` is working.

---

### 3️⃣ The `select` Block

```go
select {
case <-timeOut:
    fmt.Println("Operation timed out!.. 🔴")
case <-done:
    fmt.Println("✅ Operation completed/done!")	
}
```

The **`select`** statement listens on **multiple channels simultaneously**.

It blocks until **one of the channels becomes ready**, i.e. receives a value.

---

#### Case 1: `<-timeOut`

After 3 seconds, Go’s timer goroutine does:

```go
timeOut <- time.Now()
```

So this case becomes ready and prints:

```
Operation timed out!.. 🔴
```

#### Case 2: `<-done`

If the `longRunningOp()` finishes before the 3 seconds elapse,
it sends a signal into `done`, and this case executes instead:

```
✅ Operation completed/done!
```

---

### 4️⃣ The Long Running Function

```go
func longRunningOp() {
	for i := range 20 {
		fmt.Println(i)
		time.Sleep(time.Second)
	}
}
```

This function loops 20 times, printing each number with a 1-second pause.
That means it takes **~20 seconds** in total to complete.

---

### 5️⃣ What Actually Happens (Timeline)

#### 🧩 Real Execution Flow:

| Time (s) | Event                                                                        |
| -------- | ---------------------------------------------------------------------------- |
| 0        | `time.After(3s)` created (non-blocking)                                      |
| 0        | Goroutine starts `longRunningOp()`                                           |
| 0–1–2    | It prints: `0`, `1`, `2`                                                     |
| 3        | Timeout channel fires → select unblocks                                      |
| 3        | Prints `Operation timed out!.. 🔴`                                           |
| 3–∞      | `longRunningOp()` keeps running (but main exits soon after select completes) |

So the output is:

```
0
1
2
Operation timed out!.. 🔴
```

---

## 🔍 Under the Hood

### 🔹 `time.After(d)` Internals

When we call `time.After(3 * time.Second)`:

* Go creates a **new timer** in its internal min-heap (like in `NewTimer()`).
* The runtime tracks when 3 seconds elapse.
* After 3s, it performs a **non-blocking send** on that internal channel.

---

### 🔹 `select` Mechanism

The Go runtime monitors all channels in a `select`.
When one becomes ready (has a value or is closed):

* The corresponding case executes immediately.
* Other cases are ignored.

Here:

* `select` blocks on both `timeOut` and `done`.
* Whichever happens first determines the outcome.

---

## 🧠 Why We Use This Pattern

This is one of the **most common and idiomatic timeout patterns** in Go.

✅ **Simple timeout control**

```go
select {
case <-time.After(5 * time.Second):
    fmt.Println("Request timed out")
case result := <-response:
    fmt.Println("Got result:", result)
}
```

✅ **Combine with network operations**
We can wrap HTTP requests, DB queries, or API calls.

✅ **Avoid deadlocks**
Ensures that we never block forever if something hangs.

---

## ⚡ Enhancement Tip

Right now, even after timeout, the goroutine keeps running.
We can stop it using **`context.WithTimeout()`** to cancel the goroutine too.

Example (cleaner, cancellable version):

```go
ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
defer cancel()

done := make(chan bool)

go func() {
	longRunningOp()
	done <- true
}()

select {
case <-ctx.Done():
	fmt.Println("Operation timed out!.. 🔴")
case <-done:
	fmt.Println("✅ Operation completed/done!")	
}
```

Here, once timeout happens, the context signals cancellation —
and we can make `longRunningOp()` **listen for that context** to gracefully stop.

---

## 🧩 Summary Table

| Concept         | Description                                          |
| --------------- | ---------------------------------------------------- |
| `time.After(d)` | Returns a channel that fires once after duration `d` |
| `select`        | Waits for the first channel to be ready              |
| `done` channel  | Signals operation completion                         |
| Timeout case    | Prints message if operation takes too long           |
| Main use        | Timeouts in concurrent operations                    |

---

### Delayed Ops.
```go 
package main

import (
	"fmt"
	"time"
)

// Scheduling delayed operations.
func main() {
	timer:=time.NewTimer(2*time.Second) // non-blocking timer
	go func() {
		<- timer.C
		fmt.Println("✅ Delayed Op. executed ⌛")
	}()

	fmt.Println("Waiting.. ")
	time.Sleep(3*time.Second) // blocking timer
	fmt.Println("End of the program.. ☑️")

	// OP:
	// 	$ go run .
	// Waiting.. 
	// ✅ Delayed Op. executed ⌛
	// End of the program.. ☑️

}
```

### Multiple TIMERS
```go
package main

import (
	"fmt"
	"time"
)

func main() {
	timer1 := time.NewTimer(1 * time.Second)
	timer2 := time.NewTimer(2 * time.Second)

	for range 2 {
		select {
		case <-timer1.C:
			fmt.Println("Timer 1 expired!")
		case <-timer2.C:
			fmt.Println("Timer 2 expired!")
		}
	}
	// O/P:
	// $ go run .
	// Timer 1 expired!
	// Timer 2 expired!
}
```

