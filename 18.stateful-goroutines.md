```go
package main

import (
	"fmt"
	"time"
)

// stateful groutines - state is preserved between contexts
// COUNTER example

type StatefulWorker struct{
	count int
	ch chan int
}

// Receivig value from ch.
func(sw *StatefulWorker) Start(){
	go func() {
		// infinite loop
		for {
			select {
			case value:= <-sw.ch:
				sw.count+=value
				fmt.Println("âœ… Curr. count:",sw.count)
				
			}
		}
	}()
}

// Sending value to ch.
func(sw *StatefulWorker) Send(value int){
	sw.ch <- value
}

func main() {
	stWorker:= &StatefulWorker{
		ch: make(chan int),
	}
	stWorker.Start()

	for i:=range 5{
		stWorker.Send(i)
		time.Sleep(500*time.Millisecond)
	}
}

// O.P - 
// âœ… Curr. count: 0
// âœ… Curr. count: 1
// âœ… Curr. count: 3
// âœ… Curr. count: 6
// âœ… Curr. count: 10

// ðŸ’¡ Best practices with STATEFUL GOROUTINES- 
// 1. Encapsulate State
// 2. Sync. State
// 3. Sync. Access
// 4. Monitor & Debug
```
Letâ€™s break this code **line-by-line and conceptually**, because itâ€™s a **perfect demonstration of a stateful goroutine** in Go. ðŸ§ 

---

## ðŸ§© Overview

This code creates a **stateful worker goroutine** that:

* Keeps its own **internal counter (`count`)** as *state*.
* **Listens** for numbers on a channel (`ch`).
* **Updates** the state each time it receives a new number.
* **Preserves** this state between executions â€” i.e., the value of `count` keeps accumulating.

---

## âš™ï¸ Step-by-Step Breakdown

### ðŸ—ï¸ 1. Struct Definition

```go
type StatefulWorker struct {
	count int
	ch    chan int
}
```

* `count` â†’ internal state, starts at `0` (default int value).
* `ch` â†’ communication channel for sending integers to this worker.

So, the **state** (the `count`) is owned privately by this worker goroutine.

---

### ðŸ§µ 2. The `Start()` Method

```go
func (sw *StatefulWorker) Start() {
	go func() {
		for {
			select {
			case value := <-sw.ch:
				sw.count += value
				fmt.Println("âœ… Curr. count:", sw.count)
			}
		}
	}()
}
```

#### Explanation:

* Launches a **goroutine** â€” a concurrent, independent thread of execution.
* Inside the goroutine:

  * It continuously **listens** for values on the `sw.ch` channel.
  * When a value arrives (`value := <-sw.ch`):

    * It **adds** that value to the internal `count`.
    * Prints the updated `count`.

#### ðŸ’¡ Key Insight:

* This goroutine **never terminates** (`for {}` loop).
* It **preserves** its internal state (`sw.count`) across messages.
* It **owns** the `count` â€” no other goroutine touches it.

This is why itâ€™s called a **stateful goroutine** â€” its state *persists* across multiple channel messages.

---

### ðŸ“¨ 3. The `Send()` Method

```go
func (sw *StatefulWorker) Send(value int) {
	sw.ch <- value
}
```

* A helper function to **send** integers to the channel.
* Itâ€™s a **wrapper** around `sw.ch <- value`, making the usage cleaner.

So from outside, other goroutines donâ€™t directly access `sw.ch` â€” they only call `Send()`.

---

### ðŸš€ 4. The `main()` Function

```go
func main() {
	stWorker := &StatefulWorker{
		ch: make(chan int),
	}
	stWorker.Start()

	for i := range 5 {
		stWorker.Send(i)
		time.Sleep(500 * time.Millisecond)
	}
}
```

#### Breakdown:

1. **Create a StatefulWorker**

   ```go
   stWorker := &StatefulWorker{ch: make(chan int)}
   ```

   * A new instance with `count = 0` (default) and a `chan int` created.

2. **Start the worker**

   ```go
   stWorker.Start()
   ```

   * Spawns the goroutine that will handle all incoming values and update state.

3. **Send values 0 â†’ 4**

   ```go
   for i := range 5 {
       stWorker.Send(i)
       time.Sleep(500 * time.Millisecond)
   }
   ```

   * Sequentially sends 5 integers to the worker, spaced by 0.5s.

---

## ðŸ§® 5. Letâ€™s Trace the Execution

| Step | Value Sent (`i`) | Prev Count | New Count (`sw.count += i`) | Printed Output    |
| ---- | ---------------- | ---------- | --------------------------- | ----------------- |
| 1    | 0                | 0          | 0 + 0 = **0**               | âœ… Curr. count: 0  |
| 2    | 1                | 0          | 0 + 1 = **1**               | âœ… Curr. count: 1  |
| 3    | 2                | 1          | 1 + 2 = **3**               | âœ… Curr. count: 3  |
| 4    | 3                | 3          | 3 + 3 = **6**               | âœ… Curr. count: 6  |
| 5    | 4                | 6          | 6 + 4 = **10**              | âœ… Curr. count: 10 |

So the counter **preserves** its internal state between messages.

---

## ðŸ§  6. Why Itâ€™s â€œStatefulâ€

Unlike a stateless goroutine (which just executes a task and ends), this goroutine:

* **Lives indefinitely.**
* **Maintains internal memory (`count`).**
* **Responds to input events (channel messages).**

Itâ€™s conceptually like an **actor** or a **mini service** that processes commands serially and maintains its own internal state safely.

---

## âš¡ 7. Key Characteristics

| Concept              | Description                                            |
| -------------------- | ------------------------------------------------------ |
| **Concurrency-safe** | Only one goroutine updates `count`, so no mutex needed |
| **Persistent state** | `count` lives for the lifetime of the goroutine        |
| **Message-driven**   | Interactions happen only through the `ch` channel      |
| **Isolation**        | No other goroutine can directly access `count`         |

---

## ðŸ§± 8. Visualization (Mental Model)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Stateful Goroutine        â”‚
â”‚  -----------------------   â”‚
â”‚  count = 10                â”‚
â”‚  ch â† receives ints        â”‚
â”‚                            â”‚
â”‚  loop {                    â”‚
â”‚    value := <-ch           â”‚
â”‚    count += value          â”‚
â”‚  }                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
       Sends integers via channel
          (main goroutine)
```

---

## âœ… Summary

| Concept    | Description                                                       |
| ---------- | ----------------------------------------------------------------- |
| **What**   | A persistent goroutine maintaining internal state (`count`)       |
| **How**    | Listens to a channel, updates state based on received values      |
| **Why**    | To model concurrent systems without locks or shared-memory issues |
| **Output** | Accumulating sum printed each time a message is processed         |

---
