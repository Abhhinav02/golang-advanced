```go
package main

import (
	"fmt"
	"time"
)

// stateful groutines - state is preserved between contexts
// COUNTER example

type StatefulWorker struct{
	count int
	ch chan int
}

// Receivig value from ch.
func(sw *StatefulWorker) Start(){
	go func() {
		// infinite loop
		for {
			select {
			case value:= <-sw.ch:
				sw.count+=value
				fmt.Println("✅ Curr. count:",sw.count)
				
			}
		}
	}()
}

// Sending value to ch.
func(sw *StatefulWorker) Send(value int){
	sw.ch <- value
}

func main() {
	stWorker:= &StatefulWorker{
		ch: make(chan int),
	}
	stWorker.Start()

	for i:=range 5{
		stWorker.Send(i)
		time.Sleep(500*time.Millisecond)
	}
}

// O.P - 
// ✅ Curr. count: 0
// ✅ Curr. count: 1
// ✅ Curr. count: 3
// ✅ Curr. count: 6
// ✅ Curr. count: 10

// 💡 Best practices with STATEFUL GOROUTINES- 
// 1. Encapsulate State
// 2. Sync. State
// 3. Sync. Access
// 4. Monitor & Debug
```
Let’s break this code **line-by-line and conceptually**, because it’s a **perfect demonstration of a stateful goroutine** in Go. 🧠

---

## 🧩 Overview

This code creates a **stateful worker goroutine** that:

* Keeps its own **internal counter (`count`)** as *state*.
* **Listens** for numbers on a channel (`ch`).
* **Updates** the state each time it receives a new number.
* **Preserves** this state between executions — i.e., the value of `count` keeps accumulating.

---

## ⚙️ Step-by-Step Breakdown

### 🏗️ 1. Struct Definition

```go
type StatefulWorker struct {
	count int
	ch    chan int
}
```

* `count` → internal state, starts at `0` (default int value).
* `ch` → communication channel for sending integers to this worker.

So, the **state** (the `count`) is owned privately by this worker goroutine.

---

### 🧵 2. The `Start()` Method

```go
func (sw *StatefulWorker) Start() {
	go func() {
		for {
			select {
			case value := <-sw.ch:
				sw.count += value
				fmt.Println("✅ Curr. count:", sw.count)
			}
		}
	}()
}
```

#### Explanation:

* Launches a **goroutine** — a concurrent, independent thread of execution.
* Inside the goroutine:

  * It continuously **listens** for values on the `sw.ch` channel.
  * When a value arrives (`value := <-sw.ch`):

    * It **adds** that value to the internal `count`.
    * Prints the updated `count`.

#### 💡 Key Insight:

* This goroutine **never terminates** (`for {}` loop).
* It **preserves** its internal state (`sw.count`) across messages.
* It **owns** the `count` — no other goroutine touches it.

This is why it’s called a **stateful goroutine** — its state *persists* across multiple channel messages.

---

### 📨 3. The `Send()` Method

```go
func (sw *StatefulWorker) Send(value int) {
	sw.ch <- value
}
```

* A helper function to **send** integers to the channel.
* It’s a **wrapper** around `sw.ch <- value`, making the usage cleaner.

So from outside, other goroutines don’t directly access `sw.ch` — they only call `Send()`.

---

### 🚀 4. The `main()` Function

```go
func main() {
	stWorker := &StatefulWorker{
		ch: make(chan int),
	}
	stWorker.Start()

	for i := range 5 {
		stWorker.Send(i)
		time.Sleep(500 * time.Millisecond)
	}
}
```

#### Breakdown:

1. **Create a StatefulWorker**

   ```go
   stWorker := &StatefulWorker{ch: make(chan int)}
   ```

   * A new instance with `count = 0` (default) and a `chan int` created.

2. **Start the worker**

   ```go
   stWorker.Start()
   ```

   * Spawns the goroutine that will handle all incoming values and update state.

3. **Send values 0 → 4**

   ```go
   for i := range 5 {
       stWorker.Send(i)
       time.Sleep(500 * time.Millisecond)
   }
   ```

   * Sequentially sends 5 integers to the worker, spaced by 0.5s.

---

## 🧮 5. Let’s Trace the Execution

| Step | Value Sent (`i`) | Prev Count | New Count (`sw.count += i`) | Printed Output    |
| ---- | ---------------- | ---------- | --------------------------- | ----------------- |
| 1    | 0                | 0          | 0 + 0 = **0**               | ✅ Curr. count: 0  |
| 2    | 1                | 0          | 0 + 1 = **1**               | ✅ Curr. count: 1  |
| 3    | 2                | 1          | 1 + 2 = **3**               | ✅ Curr. count: 3  |
| 4    | 3                | 3          | 3 + 3 = **6**               | ✅ Curr. count: 6  |
| 5    | 4                | 6          | 6 + 4 = **10**              | ✅ Curr. count: 10 |

So the counter **preserves** its internal state between messages.

---

## 🧠 6. Why It’s “Stateful”

Unlike a stateless goroutine (which just executes a task and ends), this goroutine:

* **Lives indefinitely.**
* **Maintains internal memory (`count`).**
* **Responds to input events (channel messages).**

It’s conceptually like an **actor** or a **mini service** that processes commands serially and maintains its own internal state safely.

---

## ⚡ 7. Key Characteristics

| Concept              | Description                                            |
| -------------------- | ------------------------------------------------------ |
| **Concurrency-safe** | Only one goroutine updates `count`, so no mutex needed |
| **Persistent state** | `count` lives for the lifetime of the goroutine        |
| **Message-driven**   | Interactions happen only through the `ch` channel      |
| **Isolation**        | No other goroutine can directly access `count`         |

---

## 🧱 8. Visualization (Mental Model)

```
┌────────────────────────────┐
│  Stateful Goroutine        │
│  -----------------------   │
│  count = 10                │
│  ch ← receives ints        │
│                            │
│  loop {                    │
│    value := <-ch           │
│    count += value          │
│  }                         │
└─────────────┬──────────────┘
              │
              ▼
       Sends integers via channel
          (main goroutine)
```

---

## ✅ Summary

| Concept    | Description                                                       |
| ---------- | ----------------------------------------------------------------- |
| **What**   | A persistent goroutine maintaining internal state (`count`)       |
| **How**    | Listens to a channel, updates state based on received values      |
| **Why**    | To model concurrent systems without locks or shared-memory issues |
| **Output** | Accumulating sum printed each time a message is processed         |

---
