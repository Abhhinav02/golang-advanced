```go
// Every channel needs to be closed (buffered/unbuffered, all)
//ðŸ’¡ Closing normal/basic channel
func main() {
	ch := make(chan int)

	go func() {
		for i := range 5 {
			ch <- i
		}
		close(ch)
	}()

	for val := range ch {
		fmt.Println("Vals:",val)
	}
}

//OP:
/*$ go run .
Vals: 0
Vals: 1
Vals: 2
Vals: 3
Vals: 4
*/

//ðŸ’¡ Now.. Closed Buffer Channel
func main() {
	ch := make(chan int)
	close(ch)

	val,ok:= <- ch

	if !ok{
		fmt.Println("Channel is closed")
		return
	}
	fmt.Println("Val:",val)
	
}
//OP: Channel is closed

// ðŸ’¡ Range/Loop over a closed channel
func main() {
	ch := make(chan int)

	go func() {
		for i:=range 5{
			ch<-i
		}
		close(ch)
	}()

	for val:=range ch{
		fmt.Println("Received:",val)
	}
}

//OP:
/*
$ go run .
Received: 0
Received: 1
Received: 2
Received: 3
Received: 4
*/

// ðŸ’¡ PANICs
func main() {
	ch := make(chan int)

	go func() {
		close(ch)
		close(ch)
	}()

	time.Sleep(time.Second)

	//! ðŸ”´ panic: close of closed channel

}

// ðŸ’¡ Closing using PIPElINE pattern

func producer(ch chan <-int){
	for i:=range 5{
		ch<-i
	}
	close(ch)
}

func filter(in <- chan int, out chan <-int){
	for val:=range in{
		if val%2==0{
			// pass to the sender/other channel
			out<-val
		}
	}
	close(out)
}

func main() {
	ch1 := make(chan int)
	ch2 := make(chan int)

	go producer(ch1)
	go filter(ch1,ch2)

	for val:=range ch2{
		fmt.Println("Val:",val)
	}
// OP:
// $ go run .
// Val: 0
// Val: 2
// Val: 4
}

```