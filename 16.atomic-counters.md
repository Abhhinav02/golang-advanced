1️⃣ **ATOMIC-COUNTERS** ⏳

The following is a textbook-perfect demonstration of **atomic counters** in Go.
Let’s break it down **line by line**, from top to bottom — explaining what’s happening, how Go’s atomic operations work, and *why* this approach is safe and efficient.

---

```go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

// Atomic counter - atomic ops.
// Cruicial for safely handling shared data in concurrent programming.
// More efficeint than mutexes.

type AtomicCounter struct {
	count int64
}

func (ac *AtomicCounter) increment() {
	atomic.AddInt64(&ac.count, 1)
}

func (ac *AtomicCounter) getVal() int64{
	return atomic.LoadInt64(&ac.count)
}



func main() {
	var wg sync.WaitGroup
	numOfGoroutines:=10

	counter:= &AtomicCounter{}
	// value:=0 // ❌ unreliable

	for range numOfGoroutines{
		wg.Add(1)
		go func() {
			defer wg.Done()
			for range 1000{
				counter.increment()
				// value++ // ❌ unreliable
			}
		}()
	}

	wg.Wait()
	fmt.Printf("✅ Final value: %d\n",counter.getVal())
	// fmt.Printf("✅ Final value: %d\n",value) // ❌ unreliable result

	//O.P - ✅ Final value: 10000
}
```

## 🧩 Code overview

This program creates:

* A **shared counter** (`AtomicCounter`)
* Multiple **goroutines** that increment it concurrently
* A **WaitGroup** to synchronize goroutines
* And finally, it prints the **final safe counter value**

---

## 🧠 Step-by-step breakdown

### 1️⃣ Imports

```go
import (
	"fmt"
	"sync"
	"sync/atomic"
)
```

* **`fmt`** → for printing output
* **`sync`** → for `WaitGroup` synchronization
* **`sync/atomic`** → for atomic operations (our key focus)

---

### 2️⃣ Struct definition

```go
type AtomicCounter struct {
	count int64
}
```

* Defines a struct to wrap our counter value.
* The field `count` must be an **int64** (or int32) because atomic functions in Go only work with fixed-width integers and pointers.
* We encapsulate it inside a struct for clean, object-like behavior.

---

### 3️⃣ The increment method

```go
func (ac *AtomicCounter) increment() {
	atomic.AddInt64(&ac.count, 1)
}
```

* `atomic.AddInt64(&ac.count, 1)` is the **atomic increment operation**.
* It safely increments the value stored at `&ac.count` by 1.
* It guarantees that:

  * No other goroutine can interrupt during the read-modify-write cycle.
  * The operation happens *atomically* as a single CPU instruction.

💡 This is equivalent to:

```go
ac.count = ac.count + 1
```

—but done *safely* under concurrent access, without using a mutex.

---

### 4️⃣ The getVal method

```go
func (ac *AtomicCounter) getVal() int64{
	return atomic.LoadInt64(&ac.count)
}
```

* `atomic.LoadInt64` safely reads the value.
* Ensures visibility — i.e., you get the most recent, correct value across CPU cores.
* If we used a normal read (`return ac.count`), it might return a **stale or torn** value in concurrent situations.

---

### 5️⃣ Inside `main()`

```go
var wg sync.WaitGroup
numOfGoroutines := 10

counter := &AtomicCounter{}
```

* Creates a `WaitGroup` to wait for all goroutines to finish.
* Spawns **10 concurrent goroutines** (`numOfGoroutines`).
* `counter` is a shared atomic counter instance (shared among all goroutines).

---

### 6️⃣ Launching concurrent workers

```go
for range numOfGoroutines {
	wg.Add(1)
	go func() {
		defer wg.Done()
		for range 1000 {
			counter.increment()
		}
	}()
}
```

* We loop 10 times.
* Each iteration:

  * Increments the `WaitGroup` counter by 1.
  * Launches a goroutine that:

    * Runs 1000 increments on the shared `counter`.
    * Calls `wg.Done()` when finished (to signal completion).

So in total:

```
10 goroutines × 1000 increments = 10,000 increments total
```

---

### 7️⃣ Synchronizing all goroutines

```go
wg.Wait()
```

* Blocks the main goroutine until all 10 worker goroutines complete their work.
* Ensures we don’t print the result prematurely.

---

### 8️⃣ Printing the result

```go
fmt.Printf("✅ Final value: %d\n", counter.getVal())
```

* Once all increments are done, we load the final value atomically and print it.
* Expected output:

  ```
  ✅ Final value: 10000
  ```

---

### 9️⃣ The commented-out non-atomic version

```go
// value++ // ❌ unreliable
```

If we replaced the atomic counter with a plain integer increment:

```go
value++
```

and ran multiple goroutines simultaneously, we’d get **race conditions**, because:

* Multiple goroutines would read the same value of `value` before others finish writing.
* Some increments would be *lost*.

Example bad output:

```
✅ Final value: 9473
```

instead of `10000`.

That’s why **atomic operations** are critical when multiple goroutines access shared variables simultaneously.

---

## ⚙️ 10️⃣ How atomic operations work under the hood

When you call `atomic.AddInt64`, Go emits a CPU instruction like:

```
LOCK XADDQ [addr], reg
```

This does:

* Lock the memory bus for that operation.
* Add the register value to the memory location.
* Unlock — all in one indivisible instruction.
* No need for a mutex, no kernel-level blocking.

It’s **non-blocking**, **cache-coherent**, and **very fast**.

---

## 🧩 11️⃣ Flow summary

| Step | Action                                       | Thread Safety            |
| ---- | -------------------------------------------- | ------------------------ |
| 1    | Start 10 goroutines                          | Parallel execution       |
| 2    | Each goroutine calls `atomic.AddInt64` 1000× | Lock-free, atomic        |
| 3    | WaitGroup waits for all to finish            | Safe synchronization     |
| 4    | `atomic.LoadInt64` reads final value         | Consistent read          |
| 5    | Print result                                 | ✅ Race-free and accurate |

---

## 🧭 12️⃣ Final takeaway

| Concept            | Description                                                |
| ------------------ | ---------------------------------------------------------- |
| **Atomic counter** | A lock-free variable updated via atomic CPU instructions   |
| **Package**        | `sync/atomic`                                              |
| **Advantages**     | Faster than mutexes, non-blocking, ideal for counters      |
| **Use case**       | Incrementing simple shared variables safely                |
| **Limitation**     | Only works on primitive numeric types, not complex structs |

---

✅ **In short:**

> Every goroutine increments the same shared counter concurrently,
> but thanks to `atomic.AddInt64`, all increments are done safely,
> resulting in the correct final value without locks or race conditions.

---
