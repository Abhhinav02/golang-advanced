1ï¸âƒ£ **ATOMIC-COUNTERS** â³

The following is a textbook-perfect demonstration of **atomic counters** in Go.
Letâ€™s break it down **line by line**, from top to bottom â€” explaining whatâ€™s happening, how Goâ€™s atomic operations work, and *why* this approach is safe and efficient.

---

```go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

// Atomic counter - atomic ops.
// Cruicial for safely handling shared data in concurrent programming.
// More efficeint than mutexes.

type AtomicCounter struct {
	count int64
}

func (ac *AtomicCounter) increment() {
	atomic.AddInt64(&ac.count, 1)
}

func (ac *AtomicCounter) getVal() int64{
	return atomic.LoadInt64(&ac.count)
}



func main() {
	var wg sync.WaitGroup
	numOfGoroutines:=10

	counter:= &AtomicCounter{}
	// value:=0 // âŒ unreliable

	for range numOfGoroutines{
		wg.Add(1)
		go func() {
			defer wg.Done()
			for range 1000{
				counter.increment()
				// value++ // âŒ unreliable
			}
		}()
	}

	wg.Wait()
	fmt.Printf("âœ… Final value: %d\n",counter.getVal())
	// fmt.Printf("âœ… Final value: %d\n",value) // âŒ unreliable result

	//O.P - âœ… Final value: 10000
}
```

## ðŸ§© Code overview

This program creates:

* A **shared counter** (`AtomicCounter`)
* Multiple **goroutines** that increment it concurrently
* A **WaitGroup** to synchronize goroutines
* And finally, it prints the **final safe counter value**

---

## ðŸ§  Step-by-step breakdown

### 1ï¸âƒ£ Imports

```go
import (
	"fmt"
	"sync"
	"sync/atomic"
)
```

* **`fmt`** â†’ for printing output
* **`sync`** â†’ for `WaitGroup` synchronization
* **`sync/atomic`** â†’ for atomic operations (our key focus)

---

### 2ï¸âƒ£ Struct definition

```go
type AtomicCounter struct {
	count int64
}
```

* Defines a struct to wrap our counter value.
* The field `count` must be an **int64** (or int32) because atomic functions in Go only work with fixed-width integers and pointers.
* We encapsulate it inside a struct for clean, object-like behavior.

---

### 3ï¸âƒ£ The increment method

```go
func (ac *AtomicCounter) increment() {
	atomic.AddInt64(&ac.count, 1)
}
```

* `atomic.AddInt64(&ac.count, 1)` is the **atomic increment operation**.
* It safely increments the value stored at `&ac.count` by 1.
* It guarantees that:

  * No other goroutine can interrupt during the read-modify-write cycle.
  * The operation happens *atomically* as a single CPU instruction.

ðŸ’¡ This is equivalent to:

```go
ac.count = ac.count + 1
```

â€”but done *safely* under concurrent access, without using a mutex.

---

### 4ï¸âƒ£ The getVal method

```go
func (ac *AtomicCounter) getVal() int64{
	return atomic.LoadInt64(&ac.count)
}
```

* `atomic.LoadInt64` safely reads the value.
* Ensures visibility â€” i.e., you get the most recent, correct value across CPU cores.
* If we used a normal read (`return ac.count`), it might return a **stale or torn** value in concurrent situations.

---

### 5ï¸âƒ£ Inside `main()`

```go
var wg sync.WaitGroup
numOfGoroutines := 10

counter := &AtomicCounter{}
```

* Creates a `WaitGroup` to wait for all goroutines to finish.
* Spawns **10 concurrent goroutines** (`numOfGoroutines`).
* `counter` is a shared atomic counter instance (shared among all goroutines).

---

### 6ï¸âƒ£ Launching concurrent workers

```go
for range numOfGoroutines {
	wg.Add(1)
	go func() {
		defer wg.Done()
		for range 1000 {
			counter.increment()
		}
	}()
}
```

* We loop 10 times.
* Each iteration:

  * Increments the `WaitGroup` counter by 1.
  * Launches a goroutine that:

    * Runs 1000 increments on the shared `counter`.
    * Calls `wg.Done()` when finished (to signal completion).

So in total:

```
10 goroutines Ã— 1000 increments = 10,000 increments total
```

---

### 7ï¸âƒ£ Synchronizing all goroutines

```go
wg.Wait()
```

* Blocks the main goroutine until all 10 worker goroutines complete their work.
* Ensures we donâ€™t print the result prematurely.

---

### 8ï¸âƒ£ Printing the result

```go
fmt.Printf("âœ… Final value: %d\n", counter.getVal())
```

* Once all increments are done, we load the final value atomically and print it.
* Expected output:

  ```
  âœ… Final value: 10000
  ```

---

### 9ï¸âƒ£ The commented-out non-atomic version

```go
// value++ // âŒ unreliable
```

If we replaced the atomic counter with a plain integer increment:

```go
value++
```

and ran multiple goroutines simultaneously, weâ€™d get **race conditions**, because:

* Multiple goroutines would read the same value of `value` before others finish writing.
* Some increments would be *lost*.

Example bad output:

```
âœ… Final value: 9473
```

instead of `10000`.

Thatâ€™s why **atomic operations** are critical when multiple goroutines access shared variables simultaneously.

---

## âš™ï¸ 10ï¸âƒ£ How atomic operations work under the hood

When you call `atomic.AddInt64`, Go emits a CPU instruction like:

```
LOCK XADDQ [addr], reg
```

This does:

* Lock the memory bus for that operation.
* Add the register value to the memory location.
* Unlock â€” all in one indivisible instruction.
* No need for a mutex, no kernel-level blocking.

Itâ€™s **non-blocking**, **cache-coherent**, and **very fast**.

---

## ðŸ§© 11ï¸âƒ£ Flow summary

| Step | Action                                       | Thread Safety            |
| ---- | -------------------------------------------- | ------------------------ |
| 1    | Start 10 goroutines                          | Parallel execution       |
| 2    | Each goroutine calls `atomic.AddInt64` 1000Ã— | Lock-free, atomic        |
| 3    | WaitGroup waits for all to finish            | Safe synchronization     |
| 4    | `atomic.LoadInt64` reads final value         | Consistent read          |
| 5    | Print result                                 | âœ… Race-free and accurate |

---

## ðŸ§­ 12ï¸âƒ£ Final takeaway

| Concept            | Description                                                |
| ------------------ | ---------------------------------------------------------- |
| **Atomic counter** | A lock-free variable updated via atomic CPU instructions   |
| **Package**        | `sync/atomic`                                              |
| **Advantages**     | Faster than mutexes, non-blocking, ideal for counters      |
| **Use case**       | Incrementing simple shared variables safely                |
| **Limitation**     | Only works on primitive numeric types, not complex structs |

---

âœ… **In short:**

> Every goroutine increments the same shared counter concurrently,
> but thanks to `atomic.AddInt64`, all increments are done safely,
> resulting in the correct final value without locks or race conditions.

---
