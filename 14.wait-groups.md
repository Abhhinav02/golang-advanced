# ** CREATING WAITGROUPS ** âŒ›

---
## ğŸ§© **Overview**

This Go program demonstrates **concurrency control** using a `sync.WaitGroup`, which ensures that the **main goroutine** waits until all spawned goroutines (workers) finish their work before exiting.

---

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// wait groups (sync pkg) -  wait for a collection of goroutines to complete their execution (another mechanism apart from channels)
// why? - synchronization, coordination, resource management
// basic ops - Add(delta int), Done(), Wait()

func worker(id int, wg *sync.WaitGroup){
	defer wg.Done()
	fmt.Printf("ğŸ”µ Worker %d starting\n",id)
	time.Sleep(time.Second) // simulate some time spent on processing this task
	fmt.Printf("âœ… Worker %d finished!\n",id)
}

func main() {
	// create worker group
	var wg sync.WaitGroup
	numOfWorkers:= 3

	wg.Add(numOfWorkers)

	// Launch workers
	for i:= range numOfWorkers{
		go worker(i, &wg)
	}

	wg.Wait() // Blocking mechanism
	fmt.Println("â˜‘ï¸ All workers finished!")


	// Output:
	// $ go run .
	// ğŸ”µ Worker 2 starting
	// ğŸ”µ Worker 1 starting
	// ğŸ”µ Worker 0 starting
	// âœ… Worker 0 finished!
	// âœ… Worker 2 finished!
	// âœ… Worker 1 finished!
	// â˜‘ï¸ All workers finished!
}
```

## ğŸ§  **Concept Recap**

* **WaitGroup** is part of Goâ€™s `sync` package.
* It helps synchronize multiple goroutines â€” i.e., it waits until a specified number of them finish executing.
* Core methods:

  * `Add(delta int)` â†’ increases/decreases the internal counter.
  * `Done()` â†’ decrements the counter by 1 (same as `Add(-1)`).
  * `Wait()` â†’ blocks until the counter becomes 0.

---

## ğŸ§± **Line-by-Line Explanation**

### **1. Imports**

```go
import (
	"fmt"
	"sync"
	"time"
)
```

* `fmt` â†’ prints logs to the console.
* `sync` â†’ provides synchronization primitives (WaitGroup here).
* `time` â†’ used to simulate a delay, representing a task taking time.

---

### **2. Worker Function**

```go
func worker(id int, wg *sync.WaitGroup){
	defer wg.Done()
	fmt.Printf("ğŸ”µ Worker %d starting\n",id)
	time.Sleep(time.Second)
	fmt.Printf("âœ… Worker %d finished!\n",id)
}
```

**What happens here:**

* Each worker runs as a **separate goroutine**.
* `wg *sync.WaitGroup` is passed by pointer so all workers share the same instance.
* `defer wg.Done()` ensures that once this function completes, it notifies the WaitGroup that this goroutineâ€™s job is done.
* `time.Sleep(time.Second)` simulates real-world work (like fetching data or processing files).
* Print statements mark start and completion.

ğŸ’¡ **Under the hood:**
When `Done()` is called, the WaitGroupâ€™s internal counter is decremented by 1.

---

### **3. Inside `main()`**

```go
var wg sync.WaitGroup
numOfWorkers:= 3
```

* A **WaitGroup** named `wg` is created (value type).
* `numOfWorkers` is an integer set to 3, meaning we plan to run three concurrent workers.

---

### **4. Tell the WaitGroup how many goroutines to expect**

```go
wg.Add(numOfWorkers)
```

This sets the WaitGroupâ€™s internal counter to `3`.
From now, the `main` goroutine will wait for **three `Done()` calls** before it can proceed past `wg.Wait()`.

---

### **5. Launch workers**

```go
for i:= range numOfWorkers{
	go worker(i, &wg)
}
```

This is the **worker spawning loop**.

* It iterates over something called `range numOfWorkers`.
  Technically, in Go, `range` usually works over slices, maps, arrays, or channels â€” not integers.
  But since weâ€™re not modifying our code, letâ€™s focus conceptually:
  This loop intends to **spawn 3 concurrent worker goroutines**, each with a unique `id` (`0`, `1`, `2`).

Each iteration:

* Launches a new goroutine.
* Passes its ID and the WaitGroup reference.
* Immediately returns control to the loop (no blocking).

At runtime:
All 3 goroutines are now running concurrently and independently of `main()`.

---

### **6. Wait for them to finish**

```go
wg.Wait()
```

* The `main` goroutine calls `Wait()`, which **blocks** until all workers call `Done()`.
* Internally, WaitGroup uses a counter:

  * Starts at `3` (after `Add()`).
  * Each `worker()` calls `Done()`, so counter goes â†’ 2 â†’ 1 â†’ 0.
* When counter reaches `0`, `Wait()` unblocks.

---

### **7. Final Print**

```go
fmt.Println("â˜‘ï¸ All workers finished!")
```

Once all goroutines complete their jobs, `main()` prints this message and exits.

---

## ğŸ§® **Execution Flow**

Hereâ€™s what happens in sequence (roughly, since goroutines run concurrently):

| Step | Goroutine | Action                             | WaitGroup Counter |
| ---- | --------- | ---------------------------------- | ----------------- |
| 1    | main      | Adds 3                             | 3                 |
| 2    | main      | Launches worker 0                  | 3                 |
| 3    | main      | Launches worker 1                  | 3                 |
| 4    | main      | Launches worker 2                  | 3                 |
| 5    | worker 0  | Prints â€œstartingâ€                  | 3                 |
| 6    | worker 1  | Prints â€œstartingâ€                  | 3                 |
| 7    | worker 2  | Prints â€œstartingâ€                  | 3                 |
| 8    | worker 0  | Sleeps for 1 second                | 3                 |
| 9    | worker 1  | Sleeps for 1 second                | 3                 |
| 10   | worker 2  | Sleeps for 1 second                | 3                 |
| 11   | worker 0  | Prints â€œfinishedâ€ â†’ calls `Done()` | 2                 |
| 12   | worker 1  | Prints â€œfinishedâ€ â†’ calls `Done()` | 1                 |
| 13   | worker 2  | Prints â€œfinishedâ€ â†’ calls `Done()` | 0                 |
| 14   | main      | Wait unblocks                      | 0                 |
| 15   | main      | Prints â€œâ˜‘ï¸ All workers finished!â€  | â€”                 |

---

## ğŸ’¡ **Program Behavior**

* The order of **â€œstartingâ€** and **â€œfinishedâ€** messages is *non-deterministic* â€” depends on how the Go scheduler runs goroutines.
* Each worker executes independently and finishes after approximately 1 second.
* `main()` waits for all workers to finish before printing the final confirmation.

---

## ğŸ§  **What This Code Demonstrates**

âœ… **Concurrency:**
All workers run concurrently â€” their execution overlaps in time.

âœ… **Synchronization:**
WaitGroup ensures the main goroutine doesnâ€™t exit before all workers complete.

âœ… **Resource Coordination:**
The same WaitGroup pointer is shared safely among goroutines.

---

## ğŸ§© **Internal Mechanics (Simplified)**

`sync.WaitGroup` roughly works like this:

```go
type WaitGroup struct {
	counter int32
	sema    semaphore
}
```

* `Add(n)` increases `counter` by `n`.
* Each `Done()` decreases it by `1`.
* When `counter == 0`, the semaphore unblocks the waiting goroutine (the one calling `Wait()`).

This mechanism ensures **race-free**, **safe** synchronization across multiple goroutines.

---

âœ… **Final Understanding:**

Our program:

1. Spawns 3 workers concurrently.
2. Each worker simulates work using `time.Sleep`.
3. Each worker signals its completion using `wg.Done()`.
4. The main goroutine waits for all of them using `wg.Wait()`.
5. When all are done, it prints `"â˜‘ï¸ All workers finished!"`.

ğŸš€ Thatâ€™s concurrency + synchronization in action.

# ** WAITGROUPS + CHANNELS ** âš¡
---
The next code-snippet is a **classic Go concurrency pattern** combining **WaitGroups + Channels** to process tasks concurrently while receiving results in *real time*.
---

## ğŸ§© **Program Goal**

This Go program demonstrates how:

* Multiple **workers (goroutines)** can run concurrently to process tasks.
* **Results** can be sent through a **channel** while they are being processed.
* A **WaitGroup** ensures that all workers finish before closing the channel safely.

---

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// ğŸ’¡ WAITGROUPS WITH CHANNELS ğŸ”¥

func worker(id int, results chan<- int,wg *sync.WaitGroup){
	defer wg.Done()
	fmt.Printf("ğŸŸ¡ Worker %d starting\n",id)
	time.Sleep(2*time.Second) // simulate some time spent on processing this task
	results<-id*2 // results ch. receive some values
	fmt.Printf("ğŸŸ£ Worker %d finished!\n",id)
}

func main() {
	// create worker group
	var wg sync.WaitGroup
	numOfWorkers:= 3
	numOfJobs:=3
	results:=make(chan int, numOfJobs) // 3 buffers

	wg.Add(numOfWorkers)

	// Launch workers
	for i:= range numOfWorkers{
		go worker(i,results ,&wg)
	}

	go func() {
		wg.Wait() // Non blocking - We want to receive the vals in realtime
		close(results) 	// close the channel once all goroutines have finished

	}()

	// print the results
	for result:=range results{
		fmt.Println("âœ… Result:",result)
	}

	//fmt.Println("â˜‘ï¸ All workers finished!")


	// Output:
	// $ go run .
	// ğŸŸ¡ Worker 0 starting
	// ğŸŸ¡ Worker 2 starting
	// ğŸŸ¡ Worker 1 starting
	// ğŸŸ£ Worker 1 finished!
	// ğŸŸ£ Worker 0 finished!
	// ğŸŸ£ Worker 2 finished!
	// âœ… Result: 2
	// âœ… Result: 0
	// âœ… Result: 4
	

}
```

## âš™ï¸ **Code Breakdown**

### **1. Imports**

```go
import (
	"fmt"
	"sync"
	"time"
)
```

We import:

* `fmt` â†’ for printing.
* `sync` â†’ provides the `WaitGroup` type for synchronization.
* `time` â†’ simulates time-consuming work (sleep).

---

### **2. Worker Function**

```go
func worker(id int, results chan<- int, wg *sync.WaitGroup){
	defer wg.Done()
	fmt.Printf("ğŸŸ¡ Worker %d starting\n",id)
	time.Sleep(2*time.Second) // simulate some time spent on processing this task
	results<-id*2 // results ch. receive some values
	fmt.Printf("ğŸŸ£ Worker %d finished!\n",id)
}
```

**Purpose:**
Each `worker()` function simulates a unit of work running concurrently.

**Letâ€™s break it down:**

1. `id int` â†’ identifies each worker.
2. `results chan<- int` â†’ a *send-only channel* for sending processed results to main.
3. `wg *sync.WaitGroup` â†’ shared WaitGroup pointer for synchronization.

**Inside the function:**

* `defer wg.Done()` ensures the worker signals completion when the function ends.
* Prints a â€œstartingâ€ message.
* `time.Sleep(2 * time.Second)` simulates work that takes 2 seconds.
* After finishing, it sends a computed value (`id * 2`) into the `results` channel.
* Prints a â€œfinishedâ€ message.

So every worker runs concurrently, does some fake work, sends data, then signals itâ€™s done.

---

### **3. Inside main()**

```go
var wg sync.WaitGroup
numOfWorkers := 3
numOfJobs := 3
results := make(chan int, numOfJobs)
```

* `wg` â†’ WaitGroup to wait for all worker goroutines to finish.
* `numOfWorkers := 3` â†’ three concurrent workers will be launched.
* `numOfJobs := 3` â†’ (also 3 results expected).
* `results := make(chan int, numOfJobs)` â†’ buffered channel that can hold up to 3 integers.

**Buffer explanation:**
This means up to 3 results can sit in the channel without blocking the sending goroutine.
If it were unbuffered, each worker would block until the main goroutine received one result.

---

### **4. Add Workers to WaitGroup**

```go
wg.Add(numOfWorkers)
```

This sets the internal WaitGroup counter to 3 (the number of workers).
Now the main goroutine expects **3 `Done()` calls** before proceeding past `Wait()`.

---

### **5. Launch Workers**

```go
for i:= range numOfWorkers{
	go worker(i, results, &wg)
}
```

This loop launches **three concurrent workers**, each with a unique `id` (`0`, `1`, `2`).

Each worker:

* Runs in its own goroutine.
* Starts executing `worker()` immediately.
* Prints â€œğŸŸ¡ Worker X startingâ€.
* Sleeps 2 seconds.
* Sends result to `results` channel.
* Prints â€œğŸŸ£ Worker X finished!â€.
* Calls `wg.Done()` (from the deferred statement).

So now, 3 workers are working **simultaneously**.

---

### **6. Channel Closing Goroutine**

```go
go func() {
	wg.Wait()
	close(results)
}()
```

This is a **very important concurrency pattern**.
Letâ€™s unpack it carefully:

* This goroutine waits for **all workers** to finish (`wg.Wait()`).
* Once all workers have called `wg.Done()`, the WaitGroup counter becomes 0.
* Then, it **closes the `results` channel**.

ğŸ”¸ **Why use another goroutine?**
Because we want to start receiving results **while workers are still running**.
If we called `wg.Wait()` directly in `main`, it would block and delay receiving results until *after* all workers finished â€” defeating the purpose of real-time result collection.

---

### **7. Receive Results in Real-Time**

```go
for result := range results {
	fmt.Println("âœ… Result:", result)
}
```

This line:

* Continuously receives values from the `results` channel.
* Prints them as soon as they arrive.
* Stops automatically when the `results` channel is closed (after all workers finish).

This gives **live streaming of results** as workers complete their tasks, rather than waiting until all are done.

---

### **8. (Commented out)**

```go
//fmt.Println("â˜‘ï¸ All workers finished!")
```

This would execute *after* the `for range` loop if it were uncommented, meaning all workers completed and the channel was closed.

---

## ğŸ§® **Execution Flow Step-by-Step**

| Step | Goroutine                              | Action                                   | WaitGroup Counter |
| ---- | -------------------------------------- | ---------------------------------------- | ----------------- |
| 1    | main                                   | Adds 3 to WaitGroup                      | 3                 |
| 2    | main                                   | Launches 3 workers                       | 3                 |
| 3    | worker 0                               | â€œstartingâ€                               | 3                 |
| 4    | worker 1                               | â€œstartingâ€                               | 3                 |
| 5    | worker 2                               | â€œstartingâ€                               | 3                 |
| 6    | all workers                            | Sleep for 2s (concurrently)              | 3                 |
| 7    | after 2s                               | worker 0 sends result â†’ calls `Done()`   | 2                 |
| 8    | worker 1 sends result â†’ calls `Done()` | 1                                        |                   |
| 9    | worker 2 sends result â†’ calls `Done()` | 0                                        |                   |
| 10   | goroutine waiting on `wg.Wait()`       | wakes up â†’ closes channel                | 0                 |
| 11   | main                                   | ranges over `results`, prints all values | 0                 |

**Order of completion is non-deterministic** â€” depends on the Go scheduler and OS.
So the â€œfinishedâ€ and â€œresultâ€ messages might appear in different orders each run.

---

## ğŸ”¬ **Channel Buffering Explanation**

You created:

```go
results := make(chan int, numOfJobs)
```

Thatâ€™s a **buffered channel** with capacity 3.

* Workers can each send one result without waiting.
* The main goroutine can read results as soon as theyâ€™re available.
* Once the buffer is full, further sends block until some values are received.

This prevents blocking delays and smooths data flow between producers (workers) and consumer (main).

---

## ğŸ§  **Conceptual Summary**

| Concept                   | Role                                                            |
| ------------------------- | --------------------------------------------------------------- |
| **WaitGroup**             | Ensures main knows when all workers are done                    |
| **Channel (results)**     | Enables workers to send their output to main                    |
| **go func() with Wait()** | Ensures channel is closed *only* when all workers have finished |
| **for range results**     | Streams results live until the channel is closed                |
| **Buffered channel**      | Prevents deadlock by allowing limited queueing of results       |

---

## ğŸ§© **Output Behavior**

Example output (order may vary each run):

```
ğŸŸ¡ Worker 0 starting
ğŸŸ¡ Worker 2 starting
ğŸŸ¡ Worker 1 starting
ğŸŸ£ Worker 1 finished!
ğŸŸ£ Worker 0 finished!
ğŸŸ£ Worker 2 finished!
âœ… Result: 2
âœ… Result: 0
âœ… Result: 4
```

* Workers start together.
* All sleep for 2 seconds.
* When they wake up, they each send results.
* Main prints results as soon as they arrive.

---

âœ… **Final Understanding:**

Your program elegantly demonstrates:

* **Concurrent execution** via goroutines.
* **Synchronization** via WaitGroup.
* **Communication and result streaming** via channels.
* **Safe channel closure** using a goroutine waiting on `wg.Wait()`.

This pattern â€” *workers writing to a channel + WaitGroup ensuring all complete + channel closed after Wait()* â€” is one of the most **idiomatic Go concurrency patterns**.
