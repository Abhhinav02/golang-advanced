# **CREATING WAITGROUPS** ⌛
---
## 🧩 **Overview**

This Go program demonstrates **concurrency control** using a `sync.WaitGroup`, which ensures that the **main goroutine** waits until all spawned goroutines (workers) finish their work before exiting.

---

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// wait groups (sync pkg) -  wait for a collection of goroutines to complete their execution (another mechanism apart from channels)
// why? - synchronization, coordination, resource management
// basic ops - Add(delta int), Done(), Wait()

func worker(id int, wg *sync.WaitGroup){
	defer wg.Done()
	fmt.Printf("🔵 Worker %d starting\n",id)
	time.Sleep(time.Second) // simulate some time spent on processing this task
	fmt.Printf("✅ Worker %d finished!\n",id)
}

func main() {
	// create worker group
	var wg sync.WaitGroup
	numOfWorkers:= 3

	wg.Add(numOfWorkers)

	// Launch workers
	for i:= range numOfWorkers{
		go worker(i, &wg)
	}

	wg.Wait() // Blocking mechanism
	fmt.Println("☑️ All workers finished!")


	// Output:
	// $ go run .
	// 🔵 Worker 2 starting
	// 🔵 Worker 1 starting
	// 🔵 Worker 0 starting
	// ✅ Worker 0 finished!
	// ✅ Worker 2 finished!
	// ✅ Worker 1 finished!
	// ☑️ All workers finished!
}
```

## 🧠 **Concept Recap**

* **WaitGroup** is part of Go’s `sync` package.
* It helps synchronize multiple goroutines — i.e., it waits until a specified number of them finish executing.
* Core methods:

  * `Add(delta int)` → increases/decreases the internal counter.
  * `Done()` → decrements the counter by 1 (same as `Add(-1)`).
  * `Wait()` → blocks until the counter becomes 0.

---

## 🧱 **Line-by-Line Explanation**

### **1. Imports**

```go
import (
	"fmt"
	"sync"
	"time"
)
```

* `fmt` → prints logs to the console.
* `sync` → provides synchronization primitives (WaitGroup here).
* `time` → used to simulate a delay, representing a task taking time.

---

### **2. Worker Function**

```go
func worker(id int, wg *sync.WaitGroup){
	defer wg.Done()
	fmt.Printf("🔵 Worker %d starting\n",id)
	time.Sleep(time.Second)
	fmt.Printf("✅ Worker %d finished!\n",id)
}
```

**What happens here:**

* Each worker runs as a **separate goroutine**.
* `wg *sync.WaitGroup` is passed by pointer so all workers share the same instance.
* `defer wg.Done()` ensures that once this function completes, it notifies the WaitGroup that this goroutine’s job is done.
* `time.Sleep(time.Second)` simulates real-world work (like fetching data or processing files).
* Print statements mark start and completion.

💡 **Under the hood:**
When `Done()` is called, the WaitGroup’s internal counter is decremented by 1.

---

### **3. Inside `main()`**

```go
var wg sync.WaitGroup
numOfWorkers:= 3
```

* A **WaitGroup** named `wg` is created (value type).
* `numOfWorkers` is an integer set to 3, meaning we plan to run three concurrent workers.

---

### **4. Tell the WaitGroup how many goroutines to expect**

```go
wg.Add(numOfWorkers)
```

This sets the WaitGroup’s internal counter to `3`.
From now, the `main` goroutine will wait for **three `Done()` calls** before it can proceed past `wg.Wait()`.

---

### **5. Launch workers**

```go
for i:= range numOfWorkers{
	go worker(i, &wg)
}
```

This is the **worker spawning loop**.

* It iterates over something called `range numOfWorkers`.
  Technically, in Go, `range` usually works over slices, maps, arrays, or channels — not integers.
  But since we’re not modifying our code, let’s focus conceptually:
  This loop intends to **spawn 3 concurrent worker goroutines**, each with a unique `id` (`0`, `1`, `2`).

Each iteration:

* Launches a new goroutine.
* Passes its ID and the WaitGroup reference.
* Immediately returns control to the loop (no blocking).

At runtime:
All 3 goroutines are now running concurrently and independently of `main()`.

---

### **6. Wait for them to finish**

```go
wg.Wait()
```

* The `main` goroutine calls `Wait()`, which **blocks** until all workers call `Done()`.
* Internally, WaitGroup uses a counter:

  * Starts at `3` (after `Add()`).
  * Each `worker()` calls `Done()`, so counter goes → 2 → 1 → 0.
* When counter reaches `0`, `Wait()` unblocks.

---

### **7. Final Print**

```go
fmt.Println("☑️ All workers finished!")
```

Once all goroutines complete their jobs, `main()` prints this message and exits.

---

## 🧮 **Execution Flow**

Here’s what happens in sequence (roughly, since goroutines run concurrently):

| Step | Goroutine | Action                             | WaitGroup Counter |
| ---- | --------- | ---------------------------------- | ----------------- |
| 1    | main      | Adds 3                             | 3                 |
| 2    | main      | Launches worker 0                  | 3                 |
| 3    | main      | Launches worker 1                  | 3                 |
| 4    | main      | Launches worker 2                  | 3                 |
| 5    | worker 0  | Prints “starting”                  | 3                 |
| 6    | worker 1  | Prints “starting”                  | 3                 |
| 7    | worker 2  | Prints “starting”                  | 3                 |
| 8    | worker 0  | Sleeps for 1 second                | 3                 |
| 9    | worker 1  | Sleeps for 1 second                | 3                 |
| 10   | worker 2  | Sleeps for 1 second                | 3                 |
| 11   | worker 0  | Prints “finished” → calls `Done()` | 2                 |
| 12   | worker 1  | Prints “finished” → calls `Done()` | 1                 |
| 13   | worker 2  | Prints “finished” → calls `Done()` | 0                 |
| 14   | main      | Wait unblocks                      | 0                 |
| 15   | main      | Prints “☑️ All workers finished!”  | —                 |

---

## 💡 **Program Behavior**

* The order of **“starting”** and **“finished”** messages is *non-deterministic* — depends on how the Go scheduler runs goroutines.
* Each worker executes independently and finishes after approximately 1 second.
* `main()` waits for all workers to finish before printing the final confirmation.

---

## 🧠 **What This Code Demonstrates**

✅ **Concurrency:**
All workers run concurrently — their execution overlaps in time.

✅ **Synchronization:**
WaitGroup ensures the main goroutine doesn’t exit before all workers complete.

✅ **Resource Coordination:**
The same WaitGroup pointer is shared safely among goroutines.

---

## 🧩 **Internal Mechanics (Simplified)**

`sync.WaitGroup` roughly works like this:

```go
type WaitGroup struct {
	counter int32
	sema    semaphore
}
```

* `Add(n)` increases `counter` by `n`.
* Each `Done()` decreases it by `1`.
* When `counter == 0`, the semaphore unblocks the waiting goroutine (the one calling `Wait()`).

This mechanism ensures **race-free**, **safe** synchronization across multiple goroutines.

---

✅ **Final Understanding:**

Our program:

1. Spawns 3 workers concurrently.
2. Each worker simulates work using `time.Sleep`.
3. Each worker signals its completion using `wg.Done()`.
4. The main goroutine waits for all of them using `wg.Wait()`.
5. When all are done, it prints `"☑️ All workers finished!"`.

🚀 That’s concurrency + synchronization in action.
---

# **WAITGROUPS + CHANNELS** ⚡
---
The next code-snippet is a **classic Go concurrency pattern** combining **WaitGroups + Channels** to process tasks concurrently while receiving results in *real time*.
---

## 🧩 **Program Goal**

This Go program demonstrates how:

* Multiple **workers (goroutines)** can run concurrently to process tasks.
* **Results** can be sent through a **channel** while they are being processed.
* A **WaitGroup** ensures that all workers finish before closing the channel safely.

---

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// 💡 WAITGROUPS WITH CHANNELS 🔥

func worker(id int, results chan<- int,wg *sync.WaitGroup){
	defer wg.Done()
	fmt.Printf("🟡 Worker %d starting\n",id)
	time.Sleep(2*time.Second) // simulate some time spent on processing this task
	results<-id*2 // results ch. receive some values
	fmt.Printf("🟣 Worker %d finished!\n",id)
}

func main() {
	// create worker group
	var wg sync.WaitGroup
	numOfWorkers:= 3
	numOfJobs:=3
	results:=make(chan int, numOfJobs) // 3 buffers

	wg.Add(numOfWorkers)

	// Launch workers
	for i:= range numOfWorkers{
		go worker(i,results ,&wg)
	}

	go func() {
		wg.Wait() // Non blocking - We want to receive the vals in realtime
		close(results) 	// close the channel once all goroutines have finished

	}()

	// print the results
	for result:=range results{
		fmt.Println("✅ Result:",result)
	}

	//fmt.Println("☑️ All workers finished!")


	// Output:
	// $ go run .
	// 🟡 Worker 0 starting
	// 🟡 Worker 2 starting
	// 🟡 Worker 1 starting
	// 🟣 Worker 1 finished!
	// 🟣 Worker 0 finished!
	// 🟣 Worker 2 finished!
	// ✅ Result: 2
	// ✅ Result: 0
	// ✅ Result: 4
	

}
```

## ⚙️ **Code Breakdown**

### **1. Imports**

```go
import (
	"fmt"
	"sync"
	"time"
)
```

We import:

* `fmt` → for printing.
* `sync` → provides the `WaitGroup` type for synchronization.
* `time` → simulates time-consuming work (sleep).

---

### **2. Worker Function**

```go
func worker(id int, results chan<- int, wg *sync.WaitGroup){
	defer wg.Done()
	fmt.Printf("🟡 Worker %d starting\n",id)
	time.Sleep(2*time.Second) // simulate some time spent on processing this task
	results<-id*2 // results ch. receive some values
	fmt.Printf("🟣 Worker %d finished!\n",id)
}
```

**Purpose:**
Each `worker()` function simulates a unit of work running concurrently.

**Let’s break it down:**

1. `id int` → identifies each worker.
2. `results chan<- int` → a *send-only channel* for sending processed results to main.
3. `wg *sync.WaitGroup` → shared WaitGroup pointer for synchronization.

**Inside the function:**

* `defer wg.Done()` ensures the worker signals completion when the function ends.
* Prints a “starting” message.
* `time.Sleep(2 * time.Second)` simulates work that takes 2 seconds.
* After finishing, it sends a computed value (`id * 2`) into the `results` channel.
* Prints a “finished” message.

So every worker runs concurrently, does some fake work, sends data, then signals it’s done.

---

### **3. Inside main()**

```go
var wg sync.WaitGroup
numOfWorkers := 3
numOfJobs := 3
results := make(chan int, numOfJobs)
```

* `wg` → WaitGroup to wait for all worker goroutines to finish.
* `numOfWorkers := 3` → three concurrent workers will be launched.
* `numOfJobs := 3` → (also 3 results expected).
* `results := make(chan int, numOfJobs)` → buffered channel that can hold up to 3 integers.

**Buffer explanation:**
This means up to 3 results can sit in the channel without blocking the sending goroutine.
If it were unbuffered, each worker would block until the main goroutine received one result.

---

### **4. Add Workers to WaitGroup**

```go
wg.Add(numOfWorkers)
```

This sets the internal WaitGroup counter to 3 (the number of workers).
Now the main goroutine expects **3 `Done()` calls** before proceeding past `Wait()`.

---

### **5. Launch Workers**

```go
for i:= range numOfWorkers{
	go worker(i, results, &wg)
}
```

This loop launches **three concurrent workers**, each with a unique `id` (`0`, `1`, `2`).

Each worker:

* Runs in its own goroutine.
* Starts executing `worker()` immediately.
* Prints “🟡 Worker X starting”.
* Sleeps 2 seconds.
* Sends result to `results` channel.
* Prints “🟣 Worker X finished!”.
* Calls `wg.Done()` (from the deferred statement).

So now, 3 workers are working **simultaneously**.

---

### **6. Channel Closing Goroutine**

```go
go func() {
	wg.Wait()
	close(results)
}()
```

This is a **very important concurrency pattern**.
Let’s unpack it carefully:

* This goroutine waits for **all workers** to finish (`wg.Wait()`).
* Once all workers have called `wg.Done()`, the WaitGroup counter becomes 0.
* Then, it **closes the `results` channel**.

🔸 **Why use another goroutine?**
Because we want to start receiving results **while workers are still running**.
If we called `wg.Wait()` directly in `main`, it would block and delay receiving results until *after* all workers finished — defeating the purpose of real-time result collection.

---

### **7. Receive Results in Real-Time**

```go
for result := range results {
	fmt.Println("✅ Result:", result)
}
```

This line:

* Continuously receives values from the `results` channel.
* Prints them as soon as they arrive.
* Stops automatically when the `results` channel is closed (after all workers finish).

This gives **live streaming of results** as workers complete their tasks, rather than waiting until all are done.

---

### **8. (Commented out)**

```go
//fmt.Println("☑️ All workers finished!")
```

This would execute *after* the `for range` loop if it were uncommented, meaning all workers completed and the channel was closed.

---

## 🧮 **Execution Flow Step-by-Step**

| Step | Goroutine                              | Action                                   | WaitGroup Counter |
| ---- | -------------------------------------- | ---------------------------------------- | ----------------- |
| 1    | main                                   | Adds 3 to WaitGroup                      | 3                 |
| 2    | main                                   | Launches 3 workers                       | 3                 |
| 3    | worker 0                               | “starting”                               | 3                 |
| 4    | worker 1                               | “starting”                               | 3                 |
| 5    | worker 2                               | “starting”                               | 3                 |
| 6    | all workers                            | Sleep for 2s (concurrently)              | 3                 |
| 7    | after 2s                               | worker 0 sends result → calls `Done()`   | 2                 |
| 8    | worker 1 sends result → calls `Done()` | 1                                        |                   |
| 9    | worker 2 sends result → calls `Done()` | 0                                        |                   |
| 10   | goroutine waiting on `wg.Wait()`       | wakes up → closes channel                | 0                 |
| 11   | main                                   | ranges over `results`, prints all values | 0                 |

**Order of completion is non-deterministic** — depends on the Go scheduler and OS.
So the “finished” and “result” messages might appear in different orders each run.

---

## 🔬 **Channel Buffering Explanation**

You created:

```go
results := make(chan int, numOfJobs)
```

That’s a **buffered channel** with capacity 3.

* Workers can each send one result without waiting.
* The main goroutine can read results as soon as they’re available.
* Once the buffer is full, further sends block until some values are received.

This prevents blocking delays and smooths data flow between producers (workers) and consumer (main).

---

## 🧠 **Conceptual Summary**

| Concept                   | Role                                                            |
| ------------------------- | --------------------------------------------------------------- |
| **WaitGroup**             | Ensures main knows when all workers are done                    |
| **Channel (results)**     | Enables workers to send their output to main                    |
| **go func() with Wait()** | Ensures channel is closed *only* when all workers have finished |
| **for range results**     | Streams results live until the channel is closed                |
| **Buffered channel**      | Prevents deadlock by allowing limited queueing of results       |

---

## 🧩 **Output Behavior**

Example output (order may vary each run):

```
🟡 Worker 0 starting
🟡 Worker 2 starting
🟡 Worker 1 starting
🟣 Worker 1 finished!
🟣 Worker 0 finished!
🟣 Worker 2 finished!
✅ Result: 2
✅ Result: 0
✅ Result: 4
```

* Workers start together.
* All sleep for 2 seconds.
* When they wake up, they each send results.
* Main prints results as soon as they arrive.

---

✅ **Final Understanding:**

Our program elegantly demonstrates:

* **Concurrent execution** via goroutines.
* **Synchronization** via WaitGroup.
* **Communication and result streaming** via channels.
* **Safe channel closure** using a goroutine waiting on `wg.Wait()`.

This pattern — *workers writing to a channel + WaitGroup ensuring all complete + channel closed after Wait()* — is one of the most **idiomatic Go concurrency patterns**.

---

# **WAITGROUPS + CHANNELS Ex.2** 🔥
The following example/program beautifully demonstrates **how channels and wait groups work together** to coordinate a pool of worker goroutines.

---

```go 
package main

import (
	"fmt"
	"sync"
	"time"
)

// 💡 Another example with channels

func worker(id int, tasks<- chan int,results chan<- int,wg *sync.WaitGroup){
	defer wg.Done()
	fmt.Printf("🟠 Worker %d starting\n",id)
	time.Sleep(2*time.Second)
	for task:=range tasks{
	results<-task*2
	}
	
	fmt.Printf("🟤 Worker %d finished!\n",id)
}

func main() {
	// create worker group
	var wg sync.WaitGroup
	numOfWorkers:= 3
	numOfJobs:= 5
	results:=make(chan int, numOfJobs)
	tasks:= make(chan int, numOfJobs)

	wg.Add(numOfWorkers)

	for i:= range numOfWorkers{
		go worker(i+1,tasks,results,&wg)
	}


	for i:= range numOfJobs{
		tasks <- i+1
	}

	close(tasks)

	go func() {
		wg.Wait() // Non blocking - We want to receive the vals in realtime
		close(results)

	}()

	// print the results
	for result:=range results{
		fmt.Println("✅ Result:",result)
	}

	fmt.Println("⭐ All workers finished ⭐")


	// Output:
	// $ go run .
	// 🟡 Worker 0 starting
	// 🟡 Worker 2 starting
	// 🟡 Worker 1 starting
	// 🟣 Worker 1 finished!
	// 🟣 Worker 0 finished!
	// 🟣 Worker 2 finished!
	// ✅ Result: 2
	// ✅ Result: 0
	// ✅ Result: 4

}
```

## 🧩 **Overall Concept**

We are simulating a **worker pool pattern** in Go.

* **Channels** handle communication between goroutines (sending tasks and receiving results).
* **WaitGroups** handle synchronization — ensuring all goroutines finish before closing channels.
* **Workers** process incoming jobs from a shared `tasks` channel and send results to a shared `results` channel.

This is a **classic concurrency pattern** in Go — efficient, elegant, and scalable.

---

## 🧠 **Step-by-Step Explanation**

### 1. Imports and setup

```go
import (
	"fmt"
	"sync"
	"time"
)
```

We import:

* `fmt` → for printing
* `sync` → for WaitGroups
* `time` → for simulating work delays

---

### 2. Worker function

```go
func worker(id int, tasks <-chan int, results chan<- int, wg *sync.WaitGroup) {
	defer wg.Done()
	fmt.Printf("🟠 Worker %d starting\n", id)
	time.Sleep(2 * time.Second)

	for task := range tasks {
		results <- task * 2
	}

	fmt.Printf("🟤 Worker %d finished!\n", id)
}
```

#### 🔍 Breakdown:

* `worker()` is a **concurrent function** that runs as a goroutine.
* Parameters:

  * `id int` → worker’s identifier (just for logging)
  * `tasks <-chan int` → a **receive-only** channel (the worker *receives* jobs)
  * `results chan<- int` → a **send-only** channel (the worker *sends back* computed results)
  * `wg *sync.WaitGroup` → used to signal when this worker has finished all tasks.

#### 🔁 Inside the function:

1. `defer wg.Done()` → when this worker completes, it decrements the WaitGroup counter by 1.
   (This tells main goroutine “I’m done!”)
2. `fmt.Printf("🟠 Worker %d starting\n", id)` → logs start.
3. `time.Sleep(2 * time.Second)` → simulates setup or loading delay before processing starts.
4. `for task := range tasks` → this is a **range loop over a channel**:

   * The loop keeps pulling tasks from the `tasks` channel until the channel is closed.
5. Each `task` is processed by multiplying it by 2:

   ```go
   results <- task * 2
   ```

   This sends the result back through the results channel.
6. Once `tasks` is closed and all tasks are processed, the loop ends.
7. Worker prints “finished” and `wg.Done()` executes.

---

### 3. Main function

```go
func main() {
	var wg sync.WaitGroup
	numOfWorkers := 3
	numOfJobs := 5
	results := make(chan int, numOfJobs)
	tasks := make(chan int, numOfJobs)
```

#### 🔍 Explanation:

* `wg` → used to wait for all workers to finish.
* `numOfWorkers := 3` → number of worker goroutines to launch.
* `numOfJobs := 5` → total tasks to process.
* `results` → buffered channel to store results from workers.
* `tasks` → buffered channel that will distribute jobs to workers.

---

### 4. Launch the worker goroutines

```go
wg.Add(numOfWorkers)

for i := range numOfWorkers {
	go worker(i+1, tasks, results, &wg)
}
```

#### 🔍 Explanation:

* `wg.Add(numOfWorkers)` → sets WaitGroup counter to 3 (since we’ll launch 3 workers).
* The loop launches **3 worker goroutines** concurrently.
* Each worker receives:

  * a unique ID (`i+1`)
  * shared `tasks` channel (they’ll all listen for incoming jobs)
  * shared `results` channel
  * shared `wg` reference (so they can signal completion).

All workers are now **idle and waiting** for jobs to appear in the `tasks` channel.

---

### 5. Send jobs to workers

```go
for i := range numOfJobs {
	tasks <- i + 1
}
close(tasks)
```

#### 🔍 Explanation:

* This loop sends 5 jobs: values `1, 2, 3, 4, 5` to the `tasks` channel.
* All 3 workers are *listening* on `tasks`, so they will **automatically pick up jobs concurrently**.
* Once all jobs are sent, we `close(tasks)` — this signals “no more jobs”.

Workers will process until the `tasks` channel is empty and then exit the `for task := range tasks` loop.

---

### 6. Non-blocking goroutine to close results channel

```go
go func() {
	wg.Wait()
	close(results)
}()
```

#### 🔍 Explanation:

* This **anonymous goroutine** runs alongside the main one.
* It waits for all workers to finish (`wg.Wait()`).
* Once every worker calls `wg.Done()`, this goroutine executes `close(results)`.
* We use a **separate goroutine** here so that the main goroutine can continue and read results in real-time (non-blocking behavior).

---

### 7. Receiving results

```go
for result := range results {
	fmt.Println("✅ Result:", result)
}
```

#### 🔍 Explanation:

* This `for range` loop reads from the `results` channel.
* It keeps receiving values until `results` is closed (which happens when all workers finish).
* The order of results may not match the order of tasks — since workers run concurrently.

---

### 8. Final log

```go
fmt.Println("⭐ All workers finished ⭐")
```

* This executes only when all results are received (i.e., after `results` is closed).

---

## 🧭 **Flow Summary**

Let’s visualize the timeline:

```
Main goroutine:
 ├─ Creates WaitGroup, channels, launches workers
 ├─ Sends 5 tasks → [1, 2, 3, 4, 5]
 ├─ Closes 'tasks'
 ├─ Starts goroutine to wait for all workers and close 'results'
 └─ Receives results in real time

Workers (3 goroutines):
 ├─ Wait for tasks
 ├─ Pick tasks concurrently from 'tasks'
 ├─ Process each task (multiply by 2)
 ├─ Send result to 'results'
 ├─ Finish → call wg.Done()
```

---

## ⚙️ **Concurrent Behavior**

At runtime:

* All 3 workers start roughly together.
* Tasks get distributed among them:

  * Worker 1 may take tasks 1 & 4
  * Worker 2 may take tasks 2 & 5
  * Worker 3 may take task 3
    (The exact distribution is not deterministic.)
* Results arrive as soon as each worker sends its computed value.

---

## ✅ **Purpose**

This pattern efficiently:

* Utilizes multiple goroutines to process jobs concurrently.
* Synchronizes all workers safely using a WaitGroup.
* Streams results in real-time using channels.
* Closes channels properly to avoid leaks or deadlocks.

---

## 🧩 **Key Concepts Combined**

| Concept                 | Purpose                                   |
| ----------------------- | ----------------------------------------- |
| **Channel (tasks)**     | Job queue shared among workers            |
| **Channel (results)**   | Result stream back to main goroutine      |
| **WaitGroup**           | Synchronizes worker completion            |
| **Goroutines**          | Run each worker concurrently              |
| **Anonymous goroutine** | Handles closing of results channel safely |

---
