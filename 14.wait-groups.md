
---

## 🧩 **Overview**

This Go program demonstrates **concurrency control** using a `sync.WaitGroup`, which ensures that the **main goroutine** waits until all spawned goroutines (workers) finish their work before exiting.

---

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// wait groups (sync pkg) -  wait for a collection of goroutines to complete their execution (another mechanism apart from channels)
// why? - synchronization, coordination, resource management
// basic ops - Add(delta int), Done(), Wait()

func worker(id int, wg *sync.WaitGroup){
	defer wg.Done()
	fmt.Printf("🔵 Worker %d starting\n",id)
	time.Sleep(time.Second) // simulate some time spent of processing this task
	fmt.Printf("✅ Worker %d finished!\n",id)
}

func main() {
	// create worker group
	var wg sync.WaitGroup
	numOfWorkers:= 3

	wg.Add(numOfWorkers)

	// Launch workers
	for i:= range numOfWorkers{
		go worker(i, &wg)
	}

	wg.Wait()
	fmt.Println("☑️ All workers finished!")


	// Output:
	// $ go run .
	// 🔵 Worker 2 starting
	// 🔵 Worker 1 starting
	// 🔵 Worker 0 starting
	// ✅ Worker 0 finished!
	// ✅ Worker 2 finished!
	// ✅ Worker 1 finished!
	// ☑️ All workers finished!
}
```

## 🧠 **Concept Recap**

* **WaitGroup** is part of Go’s `sync` package.
* It helps synchronize multiple goroutines — i.e., it waits until a specified number of them finish executing.
* Core methods:

  * `Add(delta int)` → increases/decreases the internal counter.
  * `Done()` → decrements the counter by 1 (same as `Add(-1)`).
  * `Wait()` → blocks until the counter becomes 0.

---

## 🧱 **Line-by-Line Explanation**

### **1. Imports**

```go
import (
	"fmt"
	"sync"
	"time"
)
```

* `fmt` → prints logs to the console.
* `sync` → provides synchronization primitives (WaitGroup here).
* `time` → used to simulate a delay, representing a task taking time.

---

### **2. Worker Function**

```go
func worker(id int, wg *sync.WaitGroup){
	defer wg.Done()
	fmt.Printf("🔵 Worker %d starting\n",id)
	time.Sleep(time.Second)
	fmt.Printf("✅ Worker %d finished!\n",id)
}
```

**What happens here:**

* Each worker runs as a **separate goroutine**.
* `wg *sync.WaitGroup` is passed by pointer so all workers share the same instance.
* `defer wg.Done()` ensures that once this function completes, it notifies the WaitGroup that this goroutine’s job is done.
* `time.Sleep(time.Second)` simulates real-world work (like fetching data or processing files).
* Print statements mark start and completion.

💡 **Under the hood:**
When `Done()` is called, the WaitGroup’s internal counter is decremented by 1.

---

### **3. Inside `main()`**

```go
var wg sync.WaitGroup
numOfWorkers:= 3
```

* A **WaitGroup** named `wg` is created (value type).
* `numOfWorkers` is an integer set to 3, meaning we plan to run three concurrent workers.

---

### **4. Tell the WaitGroup how many goroutines to expect**

```go
wg.Add(numOfWorkers)
```

This sets the WaitGroup’s internal counter to `3`.
From now, the `main` goroutine will wait for **three `Done()` calls** before it can proceed past `wg.Wait()`.

---

### **5. Launch workers**

```go
for i:= range numOfWorkers{
	go worker(i, &wg)
}
```

This is the **worker spawning loop**.

* It iterates over something called `range numOfWorkers`.
  Technically, in Go, `range` usually works over slices, maps, arrays, or channels — not integers.
  But since we’re not modifying your code, let’s focus conceptually:
  This loop intends to **spawn 3 concurrent worker goroutines**, each with a unique `id` (`0`, `1`, `2`).

Each iteration:

* Launches a new goroutine.
* Passes its ID and the WaitGroup reference.
* Immediately returns control to the loop (no blocking).

At runtime:
All 3 goroutines are now running concurrently and independently of `main()`.

---

### **6. Wait for them to finish**

```go
wg.Wait()
```

* The `main` goroutine calls `Wait()`, which **blocks** until all workers call `Done()`.
* Internally, WaitGroup uses a counter:

  * Starts at `3` (after `Add()`).
  * Each `worker()` calls `Done()`, so counter goes → 2 → 1 → 0.
* When counter reaches `0`, `Wait()` unblocks.

---

### **7. Final Print**

```go
fmt.Println("☑️ All workers finished!")
```

Once all goroutines complete their jobs, `main()` prints this message and exits.

---

## 🧮 **Execution Flow**

Here’s what happens in sequence (roughly, since goroutines run concurrently):

| Step | Goroutine | Action                             | WaitGroup Counter |
| ---- | --------- | ---------------------------------- | ----------------- |
| 1    | main      | Adds 3                             | 3                 |
| 2    | main      | Launches worker 0                  | 3                 |
| 3    | main      | Launches worker 1                  | 3                 |
| 4    | main      | Launches worker 2                  | 3                 |
| 5    | worker 0  | Prints “starting”                  | 3                 |
| 6    | worker 1  | Prints “starting”                  | 3                 |
| 7    | worker 2  | Prints “starting”                  | 3                 |
| 8    | worker 0  | Sleeps for 1 second                | 3                 |
| 9    | worker 1  | Sleeps for 1 second                | 3                 |
| 10   | worker 2  | Sleeps for 1 second                | 3                 |
| 11   | worker 0  | Prints “finished” → calls `Done()` | 2                 |
| 12   | worker 1  | Prints “finished” → calls `Done()` | 1                 |
| 13   | worker 2  | Prints “finished” → calls `Done()` | 0                 |
| 14   | main      | Wait unblocks                      | 0                 |
| 15   | main      | Prints “☑️ All workers finished!”  | —                 |

---

## 💡 **Program Behavior**

* The order of **“starting”** and **“finished”** messages is *non-deterministic* — depends on how the Go scheduler runs goroutines.
* Each worker executes independently and finishes after approximately 1 second.
* `main()` waits for all workers to finish before printing the final confirmation.

---

## 🧠 **What This Code Demonstrates**

✅ **Concurrency:**
All workers run concurrently — their execution overlaps in time.

✅ **Synchronization:**
WaitGroup ensures the main goroutine doesn’t exit before all workers complete.

✅ **Resource Coordination:**
The same WaitGroup pointer is shared safely among goroutines.

---

## 🧩 **Internal Mechanics (Simplified)**

`sync.WaitGroup` roughly works like this:

```go
type WaitGroup struct {
	counter int32
	sema    semaphore
}
```

* `Add(n)` increases `counter` by `n`.
* Each `Done()` decreases it by `1`.
* When `counter == 0`, the semaphore unblocks the waiting goroutine (the one calling `Wait()`).

This mechanism ensures **race-free**, **safe** synchronization across multiple goroutines.

---

✅ **Final Understanding:**

Our program:

1. Spawns 3 workers concurrently.
2. Each worker simulates work using `time.Sleep`.
3. Each worker signals its completion using `wg.Done()`.
4. The main goroutine waits for all of them using `wg.Wait()`.
5. When all are done, it prints `"☑️ All workers finished!"`.

🚀 That’s concurrency + synchronization in action.
