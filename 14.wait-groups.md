# 1ï¸âƒ£ **CREATING WAITGROUPS** âŒ›
---
## ğŸ§© **Overview**

This Go program demonstrates **concurrency control** using a `sync.WaitGroup`, which ensures that the **main goroutine** waits until all spawned goroutines (workers) finish their work before exiting.

---

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// wait groups (sync pkg) -  wait for a collection of goroutines to complete their execution (another mechanism apart from channels)
// why? - synchronization, coordination, resource management
// basic ops - Add(delta int), Done(), Wait()

func worker(id int, wg *sync.WaitGroup){
	defer wg.Done()
	fmt.Printf("ğŸ”µ Worker %d starting\n",id)
	time.Sleep(time.Second) // simulate some time spent on processing this task
	fmt.Printf("âœ… Worker %d finished!\n",id)
}

func main() {
	// create worker group
	var wg sync.WaitGroup
	numOfWorkers:= 3

	wg.Add(numOfWorkers)

	// Launch workers
	for i:= range numOfWorkers{
		go worker(i, &wg)
	}

	wg.Wait() // Blocking mechanism
	fmt.Println("â˜‘ï¸ All workers finished!")


	// Output:
	// $ go run .
	// ğŸ”µ Worker 2 starting
	// ğŸ”µ Worker 1 starting
	// ğŸ”µ Worker 0 starting
	// âœ… Worker 0 finished!
	// âœ… Worker 2 finished!
	// âœ… Worker 1 finished!
	// â˜‘ï¸ All workers finished!
}
```

## ğŸ§  **Concept Recap**

* **WaitGroup** is part of Goâ€™s `sync` package.
* It helps synchronize multiple goroutines â€” i.e., it waits until a specified number of them finish executing.
* Core methods:

  * `Add(delta int)` â†’ increases/decreases the internal counter.
  * `Done()` â†’ decrements the counter by 1 (same as `Add(-1)`).
  * `Wait()` â†’ blocks until the counter becomes 0.

---

## ğŸ§± **Line-by-Line Explanation**

### **1. Imports**

```go
import (
	"fmt"
	"sync"
	"time"
)
```

* `fmt` â†’ prints logs to the console.
* `sync` â†’ provides synchronization primitives (WaitGroup here).
* `time` â†’ used to simulate a delay, representing a task taking time.

---

### **2. Worker Function**

```go
func worker(id int, wg *sync.WaitGroup){
	defer wg.Done()
	fmt.Printf("ğŸ”µ Worker %d starting\n",id)
	time.Sleep(time.Second)
	fmt.Printf("âœ… Worker %d finished!\n",id)
}
```

**What happens here:**

* Each worker runs as a **separate goroutine**.
* `wg *sync.WaitGroup` is passed by pointer so all workers share the same instance.
* `defer wg.Done()` ensures that once this function completes, it notifies the WaitGroup that this goroutineâ€™s job is done.
* `time.Sleep(time.Second)` simulates real-world work (like fetching data or processing files).
* Print statements mark start and completion.

ğŸ’¡ **Under the hood:**
When `Done()` is called, the WaitGroupâ€™s internal counter is decremented by 1.

---

### **3. Inside `main()`**

```go
var wg sync.WaitGroup
numOfWorkers:= 3
```

* A **WaitGroup** named `wg` is created (value type).
* `numOfWorkers` is an integer set to 3, meaning we plan to run three concurrent workers.

---

### **4. Tell the WaitGroup how many goroutines to expect**

```go
wg.Add(numOfWorkers)
```

This sets the WaitGroupâ€™s internal counter to `3`.
From now, the `main` goroutine will wait for **three `Done()` calls** before it can proceed past `wg.Wait()`.

---

### **5. Launch workers**

```go
for i:= range numOfWorkers{
	go worker(i, &wg)
}
```

This is the **worker spawning loop**.

* It iterates over something called `range numOfWorkers`.
  Technically, in Go, `range` usually works over slices, maps, arrays, or channels â€” not integers.
  But since weâ€™re not modifying our code, letâ€™s focus conceptually:
  This loop intends to **spawn 3 concurrent worker goroutines**, each with a unique `id` (`0`, `1`, `2`).

Each iteration:

* Launches a new goroutine.
* Passes its ID and the WaitGroup reference.
* Immediately returns control to the loop (no blocking).

At runtime:
All 3 goroutines are now running concurrently and independently of `main()`.

---

### **6. Wait for them to finish**

```go
wg.Wait()
```

* The `main` goroutine calls `Wait()`, which **blocks** until all workers call `Done()`.
* Internally, WaitGroup uses a counter:

  * Starts at `3` (after `Add()`).
  * Each `worker()` calls `Done()`, so counter goes â†’ 2 â†’ 1 â†’ 0.
* When counter reaches `0`, `Wait()` unblocks.

---

### **7. Final Print**

```go
fmt.Println("â˜‘ï¸ All workers finished!")
```

Once all goroutines complete their jobs, `main()` prints this message and exits.

---

## ğŸ§® **Execution Flow**

Hereâ€™s what happens in sequence (roughly, since goroutines run concurrently):

| Step | Goroutine | Action                             | WaitGroup Counter |
| ---- | --------- | ---------------------------------- | ----------------- |
| 1    | main      | Adds 3                             | 3                 |
| 2    | main      | Launches worker 0                  | 3                 |
| 3    | main      | Launches worker 1                  | 3                 |
| 4    | main      | Launches worker 2                  | 3                 |
| 5    | worker 0  | Prints â€œstartingâ€                  | 3                 |
| 6    | worker 1  | Prints â€œstartingâ€                  | 3                 |
| 7    | worker 2  | Prints â€œstartingâ€                  | 3                 |
| 8    | worker 0  | Sleeps for 1 second                | 3                 |
| 9    | worker 1  | Sleeps for 1 second                | 3                 |
| 10   | worker 2  | Sleeps for 1 second                | 3                 |
| 11   | worker 0  | Prints â€œfinishedâ€ â†’ calls `Done()` | 2                 |
| 12   | worker 1  | Prints â€œfinishedâ€ â†’ calls `Done()` | 1                 |
| 13   | worker 2  | Prints â€œfinishedâ€ â†’ calls `Done()` | 0                 |
| 14   | main      | Wait unblocks                      | 0                 |
| 15   | main      | Prints â€œâ˜‘ï¸ All workers finished!â€  | â€”                 |

---

## ğŸ’¡ **Program Behavior**

* The order of **â€œstartingâ€** and **â€œfinishedâ€** messages is *non-deterministic* â€” depends on how the Go scheduler runs goroutines.
* Each worker executes independently and finishes after approximately 1 second.
* `main()` waits for all workers to finish before printing the final confirmation.

---

## ğŸ§  **What This Code Demonstrates**

âœ… **Concurrency:**
All workers run concurrently â€” their execution overlaps in time.

âœ… **Synchronization:**
WaitGroup ensures the main goroutine doesnâ€™t exit before all workers complete.

âœ… **Resource Coordination:**
The same WaitGroup pointer is shared safely among goroutines.

---

## ğŸ§© **Internal Mechanics (Simplified)**

`sync.WaitGroup` roughly works like this:

```go
type WaitGroup struct {
	counter int32
	sema    semaphore
}
```

* `Add(n)` increases `counter` by `n`.
* Each `Done()` decreases it by `1`.
* When `counter == 0`, the semaphore unblocks the waiting goroutine (the one calling `Wait()`).

This mechanism ensures **race-free**, **safe** synchronization across multiple goroutines.

---

âœ… **Final Understanding:**

Our program:

1. Spawns 3 workers concurrently.
2. Each worker simulates work using `time.Sleep`.
3. Each worker signals its completion using `wg.Done()`.
4. The main goroutine waits for all of them using `wg.Wait()`.
5. When all are done, it prints `"â˜‘ï¸ All workers finished!"`.

ğŸš€ Thatâ€™s concurrency + synchronization in action.
---

# 2ï¸âƒ£ **WAITGROUPS + CHANNELS** âš¡
---
The next code-snippet is a **classic Go concurrency pattern** combining **WaitGroups + Channels** to process tasks concurrently while receiving results in *real time*.
---

## ğŸ§© **Program Goal**

This Go program demonstrates how:

* Multiple **workers (goroutines)** can run concurrently to process tasks.
* **Results** can be sent through a **channel** while they are being processed.
* A **WaitGroup** ensures that all workers finish before closing the channel safely.

---

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// ğŸ’¡ WAITGROUPS WITH CHANNELS ğŸ”¥

func worker(id int, results chan<- int,wg *sync.WaitGroup){
	defer wg.Done()
	fmt.Printf("ğŸŸ¡ Worker %d starting\n",id)
	time.Sleep(2*time.Second) // simulate some time spent on processing this task
	results<-id*2 // results ch. receive some values
	fmt.Printf("ğŸŸ£ Worker %d finished!\n",id)
}

func main() {
	// create worker group
	var wg sync.WaitGroup
	numOfWorkers:= 3
	numOfJobs:=3
	results:=make(chan int, numOfJobs) // 3 buffers

	wg.Add(numOfWorkers)

	// Launch workers
	for i:= range numOfWorkers{
		go worker(i,results ,&wg)
	}

	go func() {
		wg.Wait() // Non blocking - We want to receive the vals in realtime
		close(results) 	// close the channel once all goroutines have finished

	}()

	// print the results
	for result:=range results{
		fmt.Println("âœ… Result:",result)
	}

	//fmt.Println("â˜‘ï¸ All workers finished!")


	// Output:
	// $ go run .
	// ğŸŸ¡ Worker 0 starting
	// ğŸŸ¡ Worker 2 starting
	// ğŸŸ¡ Worker 1 starting
	// ğŸŸ£ Worker 1 finished!
	// ğŸŸ£ Worker 0 finished!
	// ğŸŸ£ Worker 2 finished!
	// âœ… Result: 2
	// âœ… Result: 0
	// âœ… Result: 4
	

}
```

## âš™ï¸ **Code Breakdown**

### **1. Imports**

```go
import (
	"fmt"
	"sync"
	"time"
)
```

We import:

* `fmt` â†’ for printing.
* `sync` â†’ provides the `WaitGroup` type for synchronization.
* `time` â†’ simulates time-consuming work (sleep).

---

### **2. Worker Function**

```go
func worker(id int, results chan<- int, wg *sync.WaitGroup){
	defer wg.Done()
	fmt.Printf("ğŸŸ¡ Worker %d starting\n",id)
	time.Sleep(2*time.Second) // simulate some time spent on processing this task
	results<-id*2 // results ch. receive some values
	fmt.Printf("ğŸŸ£ Worker %d finished!\n",id)
}
```

**Purpose:**
Each `worker()` function simulates a unit of work running concurrently.

**Letâ€™s break it down:**

1. `id int` â†’ identifies each worker.
2. `results chan<- int` â†’ a *send-only channel* for sending processed results to main.
3. `wg *sync.WaitGroup` â†’ shared WaitGroup pointer for synchronization.

**Inside the function:**

* `defer wg.Done()` ensures the worker signals completion when the function ends.
* Prints a â€œstartingâ€ message.
* `time.Sleep(2 * time.Second)` simulates work that takes 2 seconds.
* After finishing, it sends a computed value (`id * 2`) into the `results` channel.
* Prints a â€œfinishedâ€ message.

So every worker runs concurrently, does some fake work, sends data, then signals itâ€™s done.

---

### **3. Inside main()**

```go
var wg sync.WaitGroup
numOfWorkers := 3
numOfJobs := 3
results := make(chan int, numOfJobs)
```

* `wg` â†’ WaitGroup to wait for all worker goroutines to finish.
* `numOfWorkers := 3` â†’ three concurrent workers will be launched.
* `numOfJobs := 3` â†’ (also 3 results expected).
* `results := make(chan int, numOfJobs)` â†’ buffered channel that can hold up to 3 integers.

**Buffer explanation:**
This means up to 3 results can sit in the channel without blocking the sending goroutine.
If it were unbuffered, each worker would block until the main goroutine received one result.

---

### **4. Add Workers to WaitGroup**

```go
wg.Add(numOfWorkers)
```

This sets the internal WaitGroup counter to 3 (the number of workers).
Now the main goroutine expects **3 `Done()` calls** before proceeding past `Wait()`.

---

### **5. Launch Workers**

```go
for i:= range numOfWorkers{
	go worker(i, results, &wg)
}
```

This loop launches **three concurrent workers**, each with a unique `id` (`0`, `1`, `2`).

Each worker:

* Runs in its own goroutine.
* Starts executing `worker()` immediately.
* Prints â€œğŸŸ¡ Worker X startingâ€.
* Sleeps 2 seconds.
* Sends result to `results` channel.
* Prints â€œğŸŸ£ Worker X finished!â€.
* Calls `wg.Done()` (from the deferred statement).

So now, 3 workers are working **simultaneously**.

---

### **6. Channel Closing Goroutine**

```go
go func() {
	wg.Wait()
	close(results)
}()
```

This is a **very important concurrency pattern**.
Letâ€™s unpack it carefully:

* This goroutine waits for **all workers** to finish (`wg.Wait()`).
* Once all workers have called `wg.Done()`, the WaitGroup counter becomes 0.
* Then, it **closes the `results` channel**.

ğŸ”¸ **Why use another goroutine?**
Because we want to start receiving results **while workers are still running**.
If we called `wg.Wait()` directly in `main`, it would block and delay receiving results until *after* all workers finished â€” defeating the purpose of real-time result collection.

---

### **7. Receive Results in Real-Time**

```go
for result := range results {
	fmt.Println("âœ… Result:", result)
}
```

This line:

* Continuously receives values from the `results` channel.
* Prints them as soon as they arrive.
* Stops automatically when the `results` channel is closed (after all workers finish).

This gives **live streaming of results** as workers complete their tasks, rather than waiting until all are done.

---

### **8. (Commented out)**

```go
//fmt.Println("â˜‘ï¸ All workers finished!")
```

This would execute *after* the `for range` loop if it were uncommented, meaning all workers completed and the channel was closed.

---

## ğŸ§® **Execution Flow Step-by-Step**

| Step | Goroutine                              | Action                                   | WaitGroup Counter |
| ---- | -------------------------------------- | ---------------------------------------- | ----------------- |
| 1    | main                                   | Adds 3 to WaitGroup                      | 3                 |
| 2    | main                                   | Launches 3 workers                       | 3                 |
| 3    | worker 0                               | â€œstartingâ€                               | 3                 |
| 4    | worker 1                               | â€œstartingâ€                               | 3                 |
| 5    | worker 2                               | â€œstartingâ€                               | 3                 |
| 6    | all workers                            | Sleep for 2s (concurrently)              | 3                 |
| 7    | after 2s                               | worker 0 sends result â†’ calls `Done()`   | 2                 |
| 8    | worker 1 sends result â†’ calls `Done()` | 1                                        |                   |
| 9    | worker 2 sends result â†’ calls `Done()` | 0                                        |                   |
| 10   | goroutine waiting on `wg.Wait()`       | wakes up â†’ closes channel                | 0                 |
| 11   | main                                   | ranges over `results`, prints all values | 0                 |

**Order of completion is non-deterministic** â€” depends on the Go scheduler and OS.
So the â€œfinishedâ€ and â€œresultâ€ messages might appear in different orders each run.

---

## ğŸ”¬ **Channel Buffering Explanation**

You created:

```go
results := make(chan int, numOfJobs)
```

Thatâ€™s a **buffered channel** with capacity 3.

* Workers can each send one result without waiting.
* The main goroutine can read results as soon as theyâ€™re available.
* Once the buffer is full, further sends block until some values are received.

This prevents blocking delays and smooths data flow between producers (workers) and consumer (main).

---

## ğŸ§  **Conceptual Summary**

| Concept                   | Role                                                            |
| ------------------------- | --------------------------------------------------------------- |
| **WaitGroup**             | Ensures main knows when all workers are done                    |
| **Channel (results)**     | Enables workers to send their output to main                    |
| **go func() with Wait()** | Ensures channel is closed *only* when all workers have finished |
| **for range results**     | Streams results live until the channel is closed                |
| **Buffered channel**      | Prevents deadlock by allowing limited queueing of results       |

---

## ğŸ§© **Output Behavior**

Example output (order may vary each run):

```
ğŸŸ¡ Worker 0 starting
ğŸŸ¡ Worker 2 starting
ğŸŸ¡ Worker 1 starting
ğŸŸ£ Worker 1 finished!
ğŸŸ£ Worker 0 finished!
ğŸŸ£ Worker 2 finished!
âœ… Result: 2
âœ… Result: 0
âœ… Result: 4
```

* Workers start together.
* All sleep for 2 seconds.
* When they wake up, they each send results.
* Main prints results as soon as they arrive.

---

âœ… **Final Understanding:**

Our program elegantly demonstrates:

* **Concurrent execution** via goroutines.
* **Synchronization** via WaitGroup.
* **Communication and result streaming** via channels.
* **Safe channel closure** using a goroutine waiting on `wg.Wait()`.

This pattern â€” *workers writing to a channel + WaitGroup ensuring all complete + channel closed after Wait()* â€” is one of the most **idiomatic Go concurrency patterns**.

---

# 3ï¸âƒ£ **WAITGROUPS + CHANNELS Ex.2** ğŸ”¥
The following example/program beautifully demonstrates **how channels and wait groups work together** to coordinate a pool of worker goroutines.

---

```go 
package main

import (
	"fmt"
	"sync"
	"time"
)

// ğŸ’¡ Another example with channels

func worker(id int, tasks<- chan int,results chan<- int,wg *sync.WaitGroup){
	defer wg.Done()
	fmt.Printf("ğŸŸ  Worker %d starting\n",id)
	time.Sleep(2*time.Second)
	for task:=range tasks{
	results<-task*2
	}
	
	fmt.Printf("ğŸŸ¤ Worker %d finished!\n",id)
}

func main() {
	// create worker group
	var wg sync.WaitGroup
	numOfWorkers:= 3
	numOfJobs:= 5
	results:=make(chan int, numOfJobs)
	tasks:= make(chan int, numOfJobs)

	wg.Add(numOfWorkers)

	for i:= range numOfWorkers{
		go worker(i+1,tasks,results,&wg)
	}


	for i:= range numOfJobs{
		tasks <- i+1
	}

	close(tasks)

	go func() {
		wg.Wait() // Non blocking - We want to receive the vals in realtime
		close(results)

	}()

	// print the results
	for result:=range results{
		fmt.Println("âœ… Result:",result)
	}

	fmt.Println("â­ All workers finished â­")


	// Output:
	// $ go run .
	// ğŸŸ¡ Worker 0 starting
	// ğŸŸ¡ Worker 2 starting
	// ğŸŸ¡ Worker 1 starting
	// ğŸŸ£ Worker 1 finished!
	// ğŸŸ£ Worker 0 finished!
	// ğŸŸ£ Worker 2 finished!
	// âœ… Result: 2
	// âœ… Result: 0
	// âœ… Result: 4

}
```

## ğŸ§© **Overall Concept**

We are simulating a **worker pool pattern** in Go.

* **Channels** handle communication between goroutines (sending tasks and receiving results).
* **WaitGroups** handle synchronization â€” ensuring all goroutines finish before closing channels.
* **Workers** process incoming jobs from a shared `tasks` channel and send results to a shared `results` channel.

This is a **classic concurrency pattern** in Go â€” efficient, elegant, and scalable.

---

## ğŸ§  **Step-by-Step Explanation**

### 1. Imports and setup

```go
import (
	"fmt"
	"sync"
	"time"
)
```

We import:

* `fmt` â†’ for printing
* `sync` â†’ for WaitGroups
* `time` â†’ for simulating work delays

---

### 2. Worker function

```go
func worker(id int, tasks <-chan int, results chan<- int, wg *sync.WaitGroup) {
	defer wg.Done()
	fmt.Printf("ğŸŸ  Worker %d starting\n", id)
	time.Sleep(2 * time.Second)

	for task := range tasks {
		results <- task * 2
	}

	fmt.Printf("ğŸŸ¤ Worker %d finished!\n", id)
}
```

#### ğŸ” Breakdown:

* `worker()` is a **concurrent function** that runs as a goroutine.
* Parameters:

  * `id int` â†’ workerâ€™s identifier (just for logging)
  * `tasks <-chan int` â†’ a **receive-only** channel (the worker *receives* jobs)
  * `results chan<- int` â†’ a **send-only** channel (the worker *sends back* computed results)
  * `wg *sync.WaitGroup` â†’ used to signal when this worker has finished all tasks.

#### ğŸ” Inside the function:

1. `defer wg.Done()` â†’ when this worker completes, it decrements the WaitGroup counter by 1.
   (This tells main goroutine â€œIâ€™m done!â€)
2. `fmt.Printf("ğŸŸ  Worker %d starting\n", id)` â†’ logs start.
3. `time.Sleep(2 * time.Second)` â†’ simulates setup or loading delay before processing starts.
4. `for task := range tasks` â†’ this is a **range loop over a channel**:

   * The loop keeps pulling tasks from the `tasks` channel until the channel is closed.
5. Each `task` is processed by multiplying it by 2:

   ```go
   results <- task * 2
   ```

   This sends the result back through the results channel.
6. Once `tasks` is closed and all tasks are processed, the loop ends.
7. Worker prints â€œfinishedâ€ and `wg.Done()` executes.

---

### 3. Main function

```go
func main() {
	var wg sync.WaitGroup
	numOfWorkers := 3
	numOfJobs := 5
	results := make(chan int, numOfJobs)
	tasks := make(chan int, numOfJobs)
```

#### ğŸ” Explanation:

* `wg` â†’ used to wait for all workers to finish.
* `numOfWorkers := 3` â†’ number of worker goroutines to launch.
* `numOfJobs := 5` â†’ total tasks to process.
* `results` â†’ buffered channel to store results from workers.
* `tasks` â†’ buffered channel that will distribute jobs to workers.

---

### 4. Launch the worker goroutines

```go
wg.Add(numOfWorkers)

for i := range numOfWorkers {
	go worker(i+1, tasks, results, &wg)
}
```

#### ğŸ” Explanation:

* `wg.Add(numOfWorkers)` â†’ sets WaitGroup counter to 3 (since weâ€™ll launch 3 workers).
* The loop launches **3 worker goroutines** concurrently.
* Each worker receives:

  * a unique ID (`i+1`)
  * shared `tasks` channel (theyâ€™ll all listen for incoming jobs)
  * shared `results` channel
  * shared `wg` reference (so they can signal completion).

All workers are now **idle and waiting** for jobs to appear in the `tasks` channel.

---

### 5. Send jobs to workers

```go
for i := range numOfJobs {
	tasks <- i + 1
}
close(tasks)
```

#### ğŸ” Explanation:

* This loop sends 5 jobs: values `1, 2, 3, 4, 5` to the `tasks` channel.
* All 3 workers are *listening* on `tasks`, so they will **automatically pick up jobs concurrently**.
* Once all jobs are sent, we `close(tasks)` â€” this signals â€œno more jobsâ€.

Workers will process until the `tasks` channel is empty and then exit the `for task := range tasks` loop.

---

### 6. Non-blocking goroutine to close results channel

```go
go func() {
	wg.Wait()
	close(results)
}()
```

#### ğŸ” Explanation:

* This **anonymous goroutine** runs alongside the main one.
* It waits for all workers to finish (`wg.Wait()`).
* Once every worker calls `wg.Done()`, this goroutine executes `close(results)`.
* We use a **separate goroutine** here so that the main goroutine can continue and read results in real-time (non-blocking behavior).

---

### 7. Receiving results

```go
for result := range results {
	fmt.Println("âœ… Result:", result)
}
```

#### ğŸ” Explanation:

* This `for range` loop reads from the `results` channel.
* It keeps receiving values until `results` is closed (which happens when all workers finish).
* The order of results may not match the order of tasks â€” since workers run concurrently.

---

### 8. Final log

```go
fmt.Println("â­ All workers finished â­")
```

* This executes only when all results are received (i.e., after `results` is closed).

---

## ğŸ§­ **Flow Summary**

Letâ€™s visualize the timeline:

```
Main goroutine:
 â”œâ”€ Creates WaitGroup, channels, launches workers
 â”œâ”€ Sends 5 tasks â†’ [1, 2, 3, 4, 5]
 â”œâ”€ Closes 'tasks'
 â”œâ”€ Starts goroutine to wait for all workers and close 'results'
 â””â”€ Receives results in real time

Workers (3 goroutines):
 â”œâ”€ Wait for tasks
 â”œâ”€ Pick tasks concurrently from 'tasks'
 â”œâ”€ Process each task (multiply by 2)
 â”œâ”€ Send result to 'results'
 â”œâ”€ Finish â†’ call wg.Done()
```

---

## âš™ï¸ **Concurrent Behavior**

At runtime:

* All 3 workers start roughly together.
* Tasks get distributed among them:

  * Worker 1 may take tasks 1 & 4
  * Worker 2 may take tasks 2 & 5
  * Worker 3 may take task 3
    (The exact distribution is not deterministic.)
* Results arrive as soon as each worker sends its computed value.

---

## âœ… **Purpose**

This pattern efficiently:

* Utilizes multiple goroutines to process jobs concurrently.
* Synchronizes all workers safely using a WaitGroup.
* Streams results in real-time using channels.
* Closes channels properly to avoid leaks or deadlocks.

---

## ğŸ§© **Key Concepts Combined**

| Concept                 | Purpose                                   |
| ----------------------- | ----------------------------------------- |
| **Channel (tasks)**     | Job queue shared among workers            |
| **Channel (results)**   | Result stream back to main goroutine      |
| **WaitGroup**           | Synchronizes worker completion            |
| **Goroutines**          | Run each worker concurrently              |
| **Anonymous goroutine** | Handles closing of results channel safely |

---


# 4ï¸âƒ£ **WAITGROUPS + STRUCT{}** ğŸ—ï¸

This is a **beautiful real-world-style example** of using **`sync.WaitGroup` with structs** in Go ğŸš€.

---

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// Real-World scenario simulation ğŸš›

type Worker struct{
	ID int
	Task string
}

// PerformTask - worker simulation
func (w *Worker) PerformTask(wg *sync.WaitGroup){
 defer wg.Done()
 fmt.Printf("ğŸš§ Worker %d started %s ...\n",w.ID,w.Task)
 time.Sleep(2*time.Second) // time taken to complete task
 fmt.Printf("âœ… Worker %d finished %s\n",w.ID,w.Task)
}

func main() {
	// create waitgroup
	var wg sync.WaitGroup

	// define tasks to be performed by workers
	tasks:= []string{"Digging â›ï¸","Laying bricks ğŸ§±", "Painting ğŸ–Œï¸"} 

	for i,task := range tasks{
		worker := Worker{ID:i+1, Task: task}
		wg.Add(1) // can add in a loop too
		go worker.PerformTask(&wg)
	}

	// wait for all workers to finish
	wg.Wait()

	// Construction is finished
	fmt.Println("Construction completed.. â˜‘ï¸")


	// ğŸ’»Output:
	// $ go run .
	// ğŸš§ Worker 3 started Painting ğŸ–Œï¸ ...
	// ğŸš§ Worker 1 started Digging â›ï¸ ...
	// ğŸš§ Worker 2 started Laying bricks ğŸ§± ...
	// âœ… Worker 1 finished Digging â›ï¸
	// âœ… Worker 2 finished Laying bricks ğŸ§±
	// âœ… Worker 3 finished Painting ğŸ–Œï¸
	// Construction completed.. â˜‘ï¸
	
}
```

## ğŸ§© **High-Level Concept**

This program simulates a **construction site**, where:

* Each worker (`Worker` struct) performs a **task** (like digging or painting).
* Each worker runs **concurrently** as a goroutine.
* A **WaitGroup** (`sync.WaitGroup`) ensures the main goroutine waits until all workers finish before ending the program.

Itâ€™s a great example of **struct + goroutine + WaitGroup** coordination.

---

## ğŸ§± **Step-by-Step Breakdown**

### **1. Imports**

```go
import (
	"fmt"
	"sync"
	"time"
)
```

We import:

* `fmt` â€” for printing output
* `sync` â€” provides the `WaitGroup` type for synchronization
* `time` â€” used to simulate task duration (`Sleep`)

---

### **2. Struct Definition**

```go
type Worker struct{
	ID int
	Task string
}
```

* A `Worker` represents a **construction worker**.
* Fields:

  * `ID` â†’ Unique identifier for the worker (e.g., Worker 1, 2, 3)
  * `Task` â†’ What the worker is doing (e.g., â€œDiggingâ€)

This struct encapsulates data that belongs to each goroutine (its ID and assigned task).

---

### **3. Worker Method**

```go
func (w *Worker) PerformTask(wg *sync.WaitGroup){
	defer wg.Done()
	fmt.Printf("ğŸš§ Worker %d started %s ...\n", w.ID, w.Task)
	time.Sleep(2 * time.Second) // time taken to complete task
	fmt.Printf("âœ… Worker %d finished %s\n", w.ID, w.Task)
}
```

#### ğŸ” Explanation:

* This is a **method** with a pointer receiver (`*Worker`), meaning it operates on the actual struct instance.
* It takes a pointer to `sync.WaitGroup` as a parameter.

#### Inside:

1. `defer wg.Done()`

   * When this method completes, it decrements the WaitGroup counter by 1.
   * Think of it as: â€œIâ€™m done with my job!â€

2. `fmt.Printf("ğŸš§ Worker %d started %s ...\n", w.ID, w.Task)`

   * Logs which worker started which task.

3. `time.Sleep(2 * time.Second)`

   * Simulates work taking some time (like digging or painting).

4. `fmt.Printf("âœ… Worker %d finished %s\n", w.ID, w.Task)`

   * Prints completion message for that worker.

Each call to `PerformTask()` runs **independently in its own goroutine**, executing these steps concurrently.

---

### **4. Main Function**

```go
func main() {
	// create waitgroup
	var wg sync.WaitGroup

	// define tasks to be performed by workers
	tasks := []string{"Digging â›ï¸","Laying bricks ğŸ§±", "Painting ğŸ–Œï¸"} 
```

* `var wg sync.WaitGroup` creates a WaitGroup instance to track multiple workers.
* `tasks` slice holds three job descriptions â€” each will be assigned to a different worker.

---

### **5. Loop through tasks**

```go
for i, task := range tasks {
	worker := Worker{ID: i+1, Task: task}
	wg.Add(1) // can add in a loop too
	go worker.PerformTask(&wg)
}
```

#### ğŸ” Explanation:

* We loop over all tasks (`tasks` slice) using `range`.
* For each task:

  * Create a new `Worker` struct with:

    * `ID` = `i+1` (since index starts at 0)
    * `Task` = current task
* Call `wg.Add(1)` â€” increments the WaitGroup counter by 1.

  * This means â€œwe have one more goroutine to wait for.â€
* `go worker.PerformTask(&wg)` launches a **new goroutine** for that worker.

  * The worker begins executing concurrently.
  * Each worker has its own copy of `Worker` struct and shares the same WaitGroup.

This loop creates **three goroutines**, each working simultaneously.

---

### **6. Wait for all workers**

```go
wg.Wait()
```

* This line blocks the **main goroutine** until the WaitGroup counter reaches 0.
* Counter starts at 3 (since `wg.Add(1)` was called three times).
* Each worker calls `wg.Done()` at the end of `PerformTask()`.
* When all 3 workers are done, counter = 0 â†’ `wg.Wait()` unblocks.

So, the main goroutine patiently waits for everyone to finish before printing the final line.

---

### **7. Final Message**

```go
fmt.Println("Construction completed.. â˜‘ï¸")
```

* Once `wg.Wait()` returns, this line executes.
* At this point, **all worker goroutines have finished** their tasks.

---

## ğŸ§­ **Concurrent Flow Visualization**

```
Main Goroutine:
 â”œâ”€ Creates WaitGroup
 â”œâ”€ Creates 3 Workers with tasks
 â”œâ”€ wg.Add(1) + go PerformTask() for each
 â”œâ”€ Calls wg.Wait()  â† blocks here until all done
 â””â”€ Prints final message

Worker Goroutine (each):
 â”œâ”€ Prints â€œstartedâ€¦â€
 â”œâ”€ Sleeps 2s
 â”œâ”€ Prints â€œfinished!â€
 â””â”€ Calls wg.Done()
```

---

## ğŸ§© **Output Explanation**

```
ğŸš§ Worker 3 started Painting ğŸ–Œï¸ ...
ğŸš§ Worker 1 started Digging â›ï¸ ...
ğŸš§ Worker 2 started Laying bricks ğŸ§± ...
âœ… Worker 1 finished Digging â›ï¸
âœ… Worker 2 finished Laying bricks ğŸ§±
âœ… Worker 3 finished Painting ğŸ–Œï¸
Construction completed.. â˜‘ï¸
```

ğŸ’¡ The **order of start and finish logs may vary** on each run because goroutines run **concurrently** â€” their execution order is **non-deterministic**.

---

## âš™ï¸ **How WaitGroup Works Internally**

`WaitGroup` is like a counter:

* `Add(1)` â†’ increment counter
* `Done()` â†’ decrement counter
* `Wait()` â†’ block until counter = 0

Example behind the scenes:

| Step            | Action            | Counter    |
| --------------- | ----------------- | ---------- |
| Before loop     | `wg = 0`          | 0          |
| 3 workers added | `Add(1)` each     | 3          |
| Worker 1 done   | `Done()`          | 2          |
| Worker 2 done   | `Done()`          | 1          |
| Worker 3 done   | `Done()`          | 0          |
| All done        | `Wait()` unblocks | âœ… Continue |

---

## ğŸ§  **Why this is a good design**

1. **Encapsulation** â€” Each workerâ€™s data (`ID`, `Task`) is part of a struct.
2. **Concurrency** â€” Each worker runs as an independent goroutine.
3. **Synchronization** â€” The WaitGroup ensures proper coordination â€” main waits for all workers.
4. **Scalability** â€” Adding more workers or tasks is as simple as adding more elements to the slice.

---

## âœ… **Summary Table**

| Concept                    | Description                                             |
| -------------------------- | ------------------------------------------------------- |
| **Struct (`Worker`)**      | Holds per-goroutine data (ID, Task)                     |
| **Method (`PerformTask`)** | Encapsulates concurrent work logic                      |
| **WaitGroup**              | Synchronizes all goroutines                             |
| **Add()**                  | Increment number of goroutines to wait for              |
| **Done()**                 | Signal completion                                       |
| **Wait()**                 | Block main until all are done                           |
| **Defer wg.Done()**        | Ensures Done() always runs even if function exits early |

---

