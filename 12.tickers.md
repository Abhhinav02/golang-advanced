## Printing time or something else:
```go
package main

import (
	"fmt"
	"time"
)

func main() {
	ticker := time.NewTicker(time.Second)

	for tick:=range ticker.C{
		fmt.Println("☑️ Tick at:",tick)
	}

}

// O.P
// $ go run .
// ☑️ Tick at: 2025-10-08 16:14:59.3888131 +0530 IST m=+1.000000001
// ☑️ Tick at: 2025-10-08 16:15:00.3888131 +0530 IST m=+2.000000001
// ☑️ Tick at: 2025-10-08 16:15:01.3888131 +0530 IST m=+3.000000001
// .... after every 1 second...

```
```go
package main

import (
	"fmt"
	"time"
)

func main() {
	ticker := time.NewTicker(time.Second)

	i:=0;
	for range ticker.C{
		i++
		fmt.Println(i)
	}

}

    // O.p
	// $ go run .
	// 1
	// 2
	// 3
	// 4
	// 5
	// ... So on...
```

## STOPPING tickers
```go
package main

import (
	"fmt"
	"time"
)

func main() {
	// STOPPING tickers to free up memory space.
	ticker := time.NewTicker(time.Second)
	defer ticker.Stop() // Turn off ticker

	i:=0;
	for range 5{
		i++
		fmt.Println(i)
	}

	// O.p
	// $ go run .
	// 1
	// 2
	// 3
	// 4
	// 5

}
```

## PERIODIC Task execution()
```go
package main

import (
	"fmt"
	"time"
)

func periodicTask(){
	fmt.Println("⌛ Performing periodic task at:",time.Now())
}

func main() {
	ticker := time.NewTicker(time.Second)
	defer ticker.Stop() // Turn off ticker

	for{
	select{
	case <-ticker.C:
		periodicTask()
	 }
	}

	

// O.p
// $ go run .
// 	⌛ Performing periodic task at: 2025-10-08 16:28:24.8883307 +0530 IST m=+6.001331601
// ⌛ Performing periodic task at: 2025-10-08 16:28:25.8885089 +0530 IST m=+7.001509801
// ⌛ Performing periodic task at: 2025-10-08 16:28:26.8879589 +0530 IST m=+8.000959801
// ⌛ Performing periodic task at: 2025-10-08 16:28:27.8880838 +0530 IST m=+9.001084701
// ⌛ Performing periodic task at: 2025-10-08 16:28:28.8878862 +0530 IST m=+10.000887101
// ⌛ Performing periodic task at: 2025-10-08 16:28:29.8882013 +0530 IST m=+11.001202201
// .... so on...
}
```

## 
