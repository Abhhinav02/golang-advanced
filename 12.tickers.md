## Printing time or something else:
```go
package main

import (
	"fmt"
	"time"
)

func main() {
	ticker := time.NewTicker(time.Second)

	for tick:=range ticker.C{
		fmt.Println("‚òëÔ∏è Tick at:",tick)
	}

}

// O.P
// $ go run .
// ‚òëÔ∏è Tick at: 2025-10-08 16:14:59.3888131 +0530 IST m=+1.000000001
// ‚òëÔ∏è Tick at: 2025-10-08 16:15:00.3888131 +0530 IST m=+2.000000001
// ‚òëÔ∏è Tick at: 2025-10-08 16:15:01.3888131 +0530 IST m=+3.000000001
// .... after every 1 second...

```
```go
package main

import (
	"fmt"
	"time"
)

func main() {
	ticker := time.NewTicker(time.Second)

	i:=0;
	for range ticker.C{
		i++
		fmt.Println(i)
	}

}

    // O.p
	// $ go run .
	// 1
	// 2
	// 3
	// 4
	// 5
	// ... So on...
```

## STOPPING tickers
```go
package main

import (
	"fmt"
	"time"
)

func main() {
	// STOPPING tickers to free up memory space.
	ticker := time.NewTicker(time.Second)
	defer ticker.Stop() // Turn off ticker

	i:=0;
	for range 5{
		i++
		fmt.Println(i)
	}

	// O.p
	// $ go run .
	// 1
	// 2
	// 3
	// 4
	// 5

}
```

## PERIODIC Task execution()
```go
package main

import (
	"fmt"
	"time"
)

func periodicTask(){
	fmt.Println("‚åõ Performing periodic task at:",time.Now())
}

func main() {
	ticker := time.NewTicker(time.Second)
	defer ticker.Stop() // Turn off ticker

	for{
	select{
	case <-ticker.C:
		periodicTask()
	 }
	}

	

// O.p
// $ go run .
// 	‚åõ Performing periodic task at: 2025-10-08 16:28:24.8883307 +0530 IST m=+6.001331601
// ‚åõ Performing periodic task at: 2025-10-08 16:28:25.8885089 +0530 IST m=+7.001509801
// ‚åõ Performing periodic task at: 2025-10-08 16:28:26.8879589 +0530 IST m=+8.000959801
// ‚åõ Performing periodic task at: 2025-10-08 16:28:27.8880838 +0530 IST m=+9.001084701
// ‚åõ Performing periodic task at: 2025-10-08 16:28:28.8878862 +0530 IST m=+10.000887101
// ‚åõ Performing periodic task at: 2025-10-08 16:28:29.8882013 +0530 IST m=+11.001202201
// .... so on...
}
```

## Polling/Scheduling - tickers + timers
```go
package main

import (
	"fmt"
	"time"
)

// tickers‚è±Ô∏è + timers‚åõ
// Scheduling loggingüìù
// Polling for updates‚öôÔ∏è
// Handling ticker-stops gracefullyü™∂

func main() {
	
	ticker := time.NewTicker(time.Second)
	stop:= time.After(5*time.Second)
	defer ticker.Stop()

	for{
	select{
	case tick:= <-ticker.C:
		fmt.Println("‚åö Tick at:",tick)
	case <- stop:
		fmt.Println("Stopping ticker.. ‚òëÔ∏è")	
		return
		}
	}
    

// O.p
// $ go run .
// ‚åö Tick at: 2025-10-08 16:44:58.8357751 +0530 IST m=+1.000557801
// ‚åö Tick at: 2025-10-08 16:44:59.8357751 +0530 IST m=+2.000557801
// ‚åö Tick at: 2025-10-08 16:45:00.8357751 +0530 IST m=+3.000557801
// ‚åö Tick at: 2025-10-08 16:45:01.8357751 +0530 IST m=+4.000557801
// ‚åö Tick at: 2025-10-08 16:45:02.8357751 +0530 IST m=+5.000557801
// Stopping ticker.. ‚òëÔ∏è
}
```