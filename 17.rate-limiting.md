# 1ï¸âƒ£ **TOKEN-BUCKET ALGORITHM IMPLEMENTATION** ğŸª£


```go 
package main

import (
	"fmt"
	"time"
)

// "Token Bucket Algorithm" implementation âš¡
// Why struct{}{} ? - No memory-overhead with an empty struct{} (0 bytes) ğŸ’¡

type RateLimiter struct {
	tokens     chan struct{}
	refillTime time.Duration
}

 func NewRateLimiter(rateLimit int, refillTime time.Duration) *RateLimiter{
	rl:= &RateLimiter{
	tokens: make(chan struct{}, rateLimit),
	refillTime: refillTime,
}
	for range rateLimit{
	rl.tokens <- struct{}{}
}
	go rl.startRefill() // goroutine running in the BG.
	return  rl
 }

 func (rl *RateLimiter) startRefill(){
	ticker:= time.NewTicker(rl.refillTime)
	defer ticker.Stop()
	for {
		select {
		case <-ticker.C:
			select {
			case rl.tokens <-struct{}{}:
			default:
			}
		}
	}
} 

func (rl *RateLimiter) allow() bool{
	select {
	case <-rl.tokens:
		return true
	default:
		return false	
	}
}

func main() {
	rateLimiter:= NewRateLimiter(5,time.Second) // 5 requests

	// Let's send 10 requests
	for range 10{
		if rateLimiter.allow(){
			fmt.Println("Request Allowed âœ…")
		}else{
			fmt.Println("Request denied âŒ")
		}
		time.Sleep(200 * time.Millisecond) // some delay
	}

}

// OUTPUT: (200 ms. interval.. â±ï¸)
// $ go run .
// Request Allowed âœ…
// Request Allowed âœ…
// Request Allowed âœ…
// Request Allowed âœ…
// Request Allowed âœ…
// Request Allowed âœ…
// Request denied âŒ
// Request denied âŒ
// Request denied âŒ
// Request denied âŒ
```

---
## ğŸ§  **Concept Recap: Token Bucket Algorithm**

* Itâ€™s a **rate-limiting algorithm** that controls how many operations (e.g., API requests) can happen per unit time.
* Think of it like a **bucket** that holds â€œtokens.â€
* Each token = 1 allowed request.
* When a request arrives:

  * If thereâ€™s a token â†’ take one out â†’ request allowed âœ…
  * If bucket empty â†’ request denied âŒ
* Tokens refill over time at a steady rate.

---

## âš™ï¸ **Our Code Walkthrough**

### 1ï¸âƒ£ Struct Definition

```go
type RateLimiter struct {
	tokens     chan struct{}
	refillTime time.Duration
}
```

* `tokens`: A **channel** of type `struct{}` used as the token bucket.

  * Why `struct{}{}`?

    * It takes **0 bytes** â€” memory-efficient.
    * We only care about the *count*, not data.
* `refillTime`: How often tokens refill.

---

### 2ï¸âƒ£ Constructor Function

```go
func NewRateLimiter(rateLimit int, refillTime time.Duration) *RateLimiter {
	rl := &RateLimiter{
		tokens: make(chan struct{}, rateLimit),
		refillTime: refillTime,
	}
	for range rateLimit {
		rl.tokens <- struct{}{}
	}
	go rl.startRefill()
	return rl
}
```

**Step-by-step:**

1. Creates a channel (`rl.tokens`) with buffer size = `rateLimit` (i.e., max tokens).
2. Fills the channel to capacity using:

   ```go
   for range rateLimit {
       rl.tokens <- struct{}{}
   }
   ```

   â†’ This simulates a **bucket initially full** of tokens.
3. Launches a **goroutine** `startRefill()` â†’ constantly refills tokens periodically.
4. Returns the new `RateLimiter` instance.

---

### 3ï¸âƒ£ Background Token Refill

```go
func (rl *RateLimiter) startRefill() {
	ticker := time.NewTicker(rl.refillTime)
	defer ticker.Stop()
	for {
		select {
		case <-ticker.C:
			select {
			case rl.tokens <- struct{}{}:
			default:
			}
		}
	}
}
```

**Detailed breakdown:**

* `time.NewTicker(rl.refillTime)` creates a **ticker** that ticks every `refillTime`.
* Each tick triggers an attempt to **add a token** back into the bucket:

  ```go
  select {
  case rl.tokens <- struct{}{}:
  default:
  }
  ```

  * Inner `select` tries to send a token.
  * If the channel is already full (bucket full) â†’ `default` executes â†’ skip (no blocking).

âœ… **Key Point:**
This ensures the bucket *never overflows* â€” it stays capped at its maximum (`rateLimit`).

---

### 4ï¸âƒ£ Request Allow Function

```go
func (rl *RateLimiter) allow() bool {
	select {
	case <-rl.tokens:
		return true
	default:
		return false	
	}
}
```

* **Try to take a token** from the channel:

  * If available â†’ remove one â†’ request allowed âœ…
  * If empty â†’ skip `default` â†’ request denied âŒ
* The `select` with `default` makes it **non-blocking** â€” it immediately decides.

---

### 5ï¸âƒ£ Main Function

```go
func main() {
	rateLimiter := NewRateLimiter(5, time.Second) // 5 requests

	for range 10 {
		if rateLimiter.allow() {
			fmt.Println("Request Allowed âœ…")
		} else {
			fmt.Println("Request denied âŒ")
		}
		time.Sleep(200 * time.Millisecond)
	}
}
```

**Logic:**

* Bucket capacity = 5 tokens.
* Refill rate = 1 token per second.
* Loop sends 10 requests, every 200ms.

---

## ğŸ§© **Execution Timeline**

| Time (approx) | Request # | Tokens before   | Allowed? | Tokens after | Explanation          |
| ------------- | --------- | --------------- | -------- | ------------ | -------------------- |
| 0s            | 1         | 5               | âœ…        | 4            | Tokens available     |
| 0.2s          | 2         | 4               | âœ…        | 3            | Tokens available     |
| 0.4s          | 3         | 3               | âœ…        | 2            | Tokens available     |
| 0.6s          | 4         | 2               | âœ…        | 1            | Tokens available     |
| 0.8s          | 5         | 1               | âœ…        | 0            | Tokens available     |
| 1.0s          | 6         | 0 â†’ +1 (refill) | âœ…        | 0            | Refill happens at 1s |
| 1.2s          | 7         | 0               | âŒ        | 0            | No token yet         |
| 1.4s          | 8         | 0               | âŒ        | 0            | No token             |
| 1.6s          | 9         | 0               | âŒ        | 0            | No token             |
| 1.8s          | 10        | 0               | âŒ        | 0            | No token             |

Thatâ€™s why output shows **6 allowed** and **4 denied**.

---

## ğŸ§­ Summary

| Concept                 | Meaning                                |
| ----------------------- | -------------------------------------- |
| **Bucket capacity**     | `rateLimit` (5 tokens)                 |
| **Refill rate**         | 1 token every `refillTime`             |
| **Token channel**       | Represents available â€œpermitsâ€         |
| **Non-blocking select** | Prevents waiting on empty/full channel |
| **Refill goroutine**    | Keeps bucket topped up periodically    |

---

## ğŸ§© Real-World Analogy

Imagine a **parking lot** with 5 spaces:

* Each car (request) takes a space (token).
* Once full â†’ new cars wait outside (denied).
* Every few seconds, one car leaves (refill), freeing up a spot.

---